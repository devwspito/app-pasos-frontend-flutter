{
  "_metadata": {
    "agentType": "techlead",
    "taskId": "c411bdaf6f49b40c30423973",
    "timestamp": "2026-01-26T17:16:22.682Z",
    "phase": "techlead",
    "epicId": "epic-flutter-foundation",
    "savedAt": "2026-01-26T17:16:22.682Z",
    "version": "1.0"
  },
  "data": {
    "epicId": "epic-flutter-foundation",
    "storiesCount": 6,
    "architecture": "## Flutter Foundation Architecture\n\n### Clean Architecture Structure\n```\nlib/\n‚îú‚îÄ‚îÄ core/                      # Shared infrastructure\n‚îÇ   ‚îú‚îÄ‚îÄ constants/             # App-wide constants\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api_constants.dart # API URLs, headers, timeouts\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ app_constants.dart # App config, storage keys\n‚îÇ   ‚îú‚îÄ‚îÄ di/                    # Dependency Injection\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ injection_container.dart\n‚îÇ   ‚îú‚îÄ‚îÄ errors/                # Error handling\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ exceptions.dart    # Data layer exceptions\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ failures.dart      # Domain layer failures + Result type\n‚îÇ   ‚îú‚îÄ‚îÄ extensions/            # Dart extensions\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ context_extensions.dart\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ string_extensions.dart\n‚îÇ   ‚îú‚îÄ‚îÄ network/               # Networking\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api_client.dart    # Dio wrapper\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api_interceptor.dart # Auth + logging interceptors\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ network_info.dart  # Connectivity checker\n‚îÇ   ‚îî‚îÄ‚îÄ utils/                 # Utilities\n‚îÇ       ‚îú‚îÄ‚îÄ logger.dart        # Centralized logging\n‚îÇ       ‚îî‚îÄ‚îÄ validators.dart    # Form validation\n‚îú‚îÄ‚îÄ env/                       # Environment config\n‚îÇ   ‚îú‚îÄ‚îÄ env.dart               # Envied configuration\n‚îÇ   ‚îî‚îÄ‚îÄ env.g.dart             # Generated (build_runner)\n‚îú‚îÄ‚îÄ features/                  # Feature modules (future epics)\n‚îú‚îÄ‚îÄ shared/                    # Shared widgets (future epics)\n‚îî‚îÄ‚îÄ main.dart                  # App entry point with DI init\n```\n\n### Dependency Injection Pattern\n- **get_it**: Service locator for dependency registration\n- **injectable**: Annotation-based DI (future code generation)\n- Singleton pattern for ApiClient, NetworkInfo\n- Factory pattern for feature-specific services\n\n### Error Handling Strategy\n- **Exceptions** (Data Layer): NetworkException, ServerException, CacheException\n- **Failures** (Domain Layer): NetworkFailure, ServerFailure, AuthFailure\n- **Result Type**: `Either<Failure, T>` using dartz for functional error handling\n\n### Environment Configuration\n- **envied**: Compile-time safe environment variables\n- **Obfuscation**: API keys obfuscated in generated code\n- **Environments**: development, staging, production\n\n### Networking Architecture\n- **Dio**: HTTP client with interceptor support\n- **AuthInterceptor**: Automatic token injection\n- **LoggingInterceptor**: Request/response logging\n- **Typed error handling**: DioException ‚Üí AppException mapping\n\n### SOLID Principles Applied\n- **SRP**: Each class has single responsibility (Logger logs, Validators validate)\n- **OCP**: NetworkInfo interface allows swapping implementations\n- **LSP**: All exceptions properly extend AppException\n- **ISP**: Small, focused interfaces (NetworkInfo)\n- **DIP**: ApiClient depends on abstractions (FlutterSecureStorage)",
    "stories": [
      {
        "id": "epic-flutter-foundation-story-1",
        "title": "Configure pubspec.yaml with all required dependencies and update analysis_options.yaml",
        "description": "Add all required Flutter dependencies for the project foundation.\n\nüîí **SCOPE BOUNDARY:**\n- You can ONLY modify files listed below\n- NO file creation in this story\n\nüìÅ **FILES:**\n- Read: pubspec.yaml, analysis_options.yaml\n- Modify: pubspec.yaml, analysis_options.yaml\n- Create: None\n\nüîß **PATTERNS TO USE:**\n- Use caret syntax for version constraints (^x.x.x)\n- Group dependencies logically with comments\n- Follow Dart SDK constraint from existing file (sdk: ^3.5.0)\n\n‚ö†Ô∏è **ANTI-PATTERNS TO AVOID:**\n- DO NOT use exact version pinning (=1.0.0)\n- DO NOT add git dependencies\n- DO NOT modify flutter section\n\nüéØ **FUNCTIONAL REQUIREMENTS:**\n\n**pubspec.yaml - Add these dependencies:**\n```yaml\ndependencies:\n  flutter:\n    sdk: flutter\n  cupertino_icons: ^1.0.8\n  # State Management\n  flutter_riverpod: ^2.5.1\n  # Networking\n  dio: ^5.4.3+1\n  # Storage\n  flutter_secure_storage: ^9.2.2\n  # Dependency Injection\n  get_it: ^7.7.0\n  injectable: ^2.4.4\n  # Environment\n  envied: ^0.5.4+1\n  # Data Classes\n  freezed_annotation: ^2.4.4\n  json_annotation: ^4.9.0\n  # Routing\n  go_router: ^14.2.7\n  # Functional Programming\n  dartz: ^0.10.1\n  # Connectivity\n  connectivity_plus: ^6.0.5\n\ndev_dependencies:\n  flutter_test:\n    sdk: flutter\n  flutter_lints: ^4.0.0\n  # Code Generation\n  build_runner: ^2.4.13\n  freezed: ^2.5.7\n  json_serializable: ^6.8.0\n  injectable_generator: ^2.6.2\n  envied_generator: ^0.5.4+1\n```\n\n**analysis_options.yaml - Add stricter rules:**\n```yaml\ninclude: package:flutter_lints/flutter.yaml\n\nanalyzer:\n  errors:\n    invalid_annotation_target: ignore\n  exclude:\n    - \"**/*.g.dart\"\n    - \"**/*.freezed.dart\"\n\nlinter:\n  rules:\n    prefer_single_quotes: true\n    always_declare_return_types: true\n    avoid_print: true\n    prefer_const_constructors: true\n    prefer_const_declarations: true\n```\n\nüß™ **VERIFICATION:**\n```bash\nflutter pub get\nflutter analyze\n```\n- All dependencies should resolve without conflicts\n- No analyzer errors",
        "epicId": "epic-flutter-foundation",
        "priority": 1,
        "estimatedComplexity": "simple",
        "dependencies": [],
        "status": "pending",
        "filesToRead": [
          "pubspec.yaml",
          "analysis_options.yaml"
        ],
        "filesToModify": [
          "pubspec.yaml",
          "analysis_options.yaml"
        ],
        "filesToCreate": [],
        "acceptanceCriteria": [
          "Given pubspec.yaml exists, When dependencies are added, Then flutter pub get succeeds without errors",
          "Given analysis_options.yaml exists, When stricter rules are added, Then flutter analyze passes",
          "Given all dependencies are added, When running build_runner, Then code generation tools are available"
        ]
      },
      {
        "id": "epic-flutter-foundation-story-2",
        "title": "Create lib/core/di/injection_container.dart and lib/core/constants/ files for DI and constants",
        "description": "Set up get_it dependency injection container and application constants.\n\nüîí **SCOPE BOUNDARY:**\n- You can ONLY create files listed below\n- Creating ANY other file is a scope violation\n\nüìÅ **FILES:**\n- Read: pubspec.yaml (verify get_it is available)\n- Modify: None\n- Create: lib/core/di/injection_container.dart, lib/core/constants/api_constants.dart, lib/core/constants/app_constants.dart\n\nüîß **PATTERNS TO USE:**\n- Use GetIt singleton pattern: `final sl = GetIt.instance;`\n- Use abstract classes for constants (non-instantiable)\n- Use static const for all constant values\n\n‚ö†Ô∏è **ANTI-PATTERNS TO AVOID:**\n- DO NOT use `new GetIt()` - use `GetIt.instance`\n- DO NOT make constants instantiable classes\n- DO NOT hardcode API URLs in injection_container (use env)\n\nüéØ **FUNCTIONAL REQUIREMENTS:**\n\n**lib/core/di/injection_container.dart:**\n```dart\nimport 'package:get_it/get_it.dart';\n\nfinal sl = GetIt.instance;\n\nFuture<void> initializeDependencies() async {\n  // External\n  // TODO: Register Dio, SharedPreferences, etc. in future stories\n  \n  // Core\n  // TODO: Register NetworkInfo, ApiClient in future stories\n  \n  // Features - Repositories\n  // TODO: Register repositories in future epics\n  \n  // Features - Use Cases\n  // TODO: Register use cases in future epics\n  \n  // Features - Blocs\n  // TODO: Register blocs in future epics\n}\n```\n\n**lib/core/constants/api_constants.dart:**\n```dart\nabstract class ApiConstants {\n  ApiConstants._();\n  \n  // Timeouts\n  static const int connectTimeout = 30000;\n  static const int receiveTimeout = 30000;\n  static const int sendTimeout = 30000;\n  \n  // Headers\n  static const String contentType = 'application/json';\n  static const String accept = 'application/json';\n  static const String authorization = 'Authorization';\n  static const String bearer = 'Bearer';\n  \n  // API Paths\n  static const String apiVersion = '/api/v1';\n  static const String authPath = '/auth';\n  static const String loginPath = '/auth/login';\n  static const String registerPath = '/auth/register';\n  static const String refreshTokenPath = '/auth/refresh';\n}\n```\n\n**lib/core/constants/app_constants.dart:**\n```dart\nabstract class AppConstants {\n  AppConstants._();\n  \n  // App Info\n  static const String appName = 'App Pasos';\n  static const String appVersion = '1.0.0';\n  \n  // Storage Keys\n  static const String accessTokenKey = 'access_token';\n  static const String refreshTokenKey = 'refresh_token';\n  static const String userKey = 'user_data';\n  static const String themeKey = 'theme_mode';\n  static const String localeKey = 'locale';\n  \n  // Pagination\n  static const int defaultPageSize = 20;\n  static const int maxPageSize = 100;\n  \n  // Validation\n  static const int minPasswordLength = 8;\n  static const int maxPasswordLength = 128;\n  static const int minUsernameLength = 3;\n  static const int maxUsernameLength = 50;\n}\n```\n\nüß™ **VERIFICATION:**\n```bash\nflutter analyze lib/core/di/\nflutter analyze lib/core/constants/\ndart format lib/core/ --set-exit-if-changed\n```\n- All files pass flutter analyze\n- Code is properly formatted",
        "epicId": "epic-flutter-foundation",
        "priority": 2,
        "estimatedComplexity": "simple",
        "dependencies": [
          "epic-flutter-foundation-story-1"
        ],
        "status": "pending",
        "filesToRead": [
          "pubspec.yaml"
        ],
        "filesToModify": [],
        "filesToCreate": [
          "lib/core/di/injection_container.dart",
          "lib/core/constants/api_constants.dart",
          "lib/core/constants/app_constants.dart"
        ],
        "acceptanceCriteria": [
          "Given get_it package is installed, When injection_container.dart is created, Then sl variable is accessible as GetIt singleton",
          "Given ApiConstants class is created, When importing the file, Then all API-related constants are accessible via static members",
          "Given AppConstants class is created, When importing the file, Then all app configuration constants are accessible"
        ]
      },
      {
        "id": "epic-flutter-foundation-story-3",
        "title": "Create lib/core/network/ files implementing Dio API client with interceptors",
        "description": "Implement Dio-based API client with authentication interceptor, error handling, and logging.\n\nüîí **SCOPE BOUNDARY:**\n- You can ONLY create files listed below\n- Creating ANY other file is a scope violation\n\nüìÅ **FILES:**\n- Read: lib/core/constants/api_constants.dart, lib/core/errors/exceptions.dart, lib/env/env.dart\n- Modify: None\n- Create: lib/core/network/api_client.dart, lib/core/network/api_interceptor.dart, lib/core/network/network_info.dart\n\nüîß **PATTERNS TO USE:**\n- Use Dio singleton with interceptors\n- Use abstract class + implementation pattern for NetworkInfo\n- Throw custom exceptions from lib/core/errors/exceptions.dart\n\n‚ö†Ô∏è **ANTI-PATTERNS TO AVOID:**\n- DO NOT create new Dio() in every API call - use singleton\n- DO NOT hardcode base URL - use Env.apiUrl\n- DO NOT catch and swallow errors - rethrow as typed exceptions\n- DO NOT use print() for logging - use the Logger utility\n\nüéØ **FUNCTIONAL REQUIREMENTS:**\n\n**lib/core/network/network_info.dart:**\n```dart\nimport 'package:connectivity_plus/connectivity_plus.dart';\n\nabstract class NetworkInfo {\n  Future<bool> get isConnected;\n}\n\nclass NetworkInfoImpl implements NetworkInfo {\n  final Connectivity connectivity;\n  \n  NetworkInfoImpl({required this.connectivity});\n  \n  @override\n  Future<bool> get isConnected async {\n    final result = await connectivity.checkConnectivity();\n    return !result.contains(ConnectivityResult.none);\n  }\n}\n```\n\n**lib/core/network/api_interceptor.dart:**\n```dart\nimport 'package:dio/dio.dart';\nimport 'package:flutter_secure_storage/flutter_secure_storage.dart';\nimport '../constants/api_constants.dart';\nimport '../constants/app_constants.dart';\nimport '../errors/exceptions.dart';\n\nclass AuthInterceptor extends Interceptor {\n  final FlutterSecureStorage secureStorage;\n  \n  AuthInterceptor({required this.secureStorage});\n  \n  @override\n  Future<void> onRequest(\n    RequestOptions options,\n    RequestInterceptorHandler handler,\n  ) async {\n    final token = await secureStorage.read(key: AppConstants.accessTokenKey);\n    if (token != null && token.isNotEmpty) {\n      options.headers[ApiConstants.authorization] = '${ApiConstants.bearer} $token';\n    }\n    handler.next(options);\n  }\n  \n  @override\n  void onError(DioException err, ErrorInterceptorHandler handler) {\n    if (err.response?.statusCode == 401) {\n      // Token expired - could trigger refresh logic here\n    }\n    handler.next(err);\n  }\n}\n\nclass LoggingInterceptor extends Interceptor {\n  @override\n  void onRequest(RequestOptions options, RequestInterceptorHandler handler) {\n    // Use Logger.debug instead of print in production\n    handler.next(options);\n  }\n  \n  @override\n  void onResponse(Response response, ResponseInterceptorHandler handler) {\n    handler.next(response);\n  }\n  \n  @override\n  void onError(DioException err, ErrorInterceptorHandler handler) {\n    handler.next(err);\n  }\n}\n```\n\n**lib/core/network/api_client.dart:**\n```dart\nimport 'package:dio/dio.dart';\nimport 'package:flutter_secure_storage/flutter_secure_storage.dart';\nimport '../constants/api_constants.dart';\nimport '../errors/exceptions.dart';\nimport 'api_interceptor.dart';\n\nclass ApiClient {\n  late final Dio _dio;\n  final String baseUrl;\n  final FlutterSecureStorage secureStorage;\n  \n  ApiClient({\n    required this.baseUrl,\n    required this.secureStorage,\n  }) {\n    _dio = Dio(\n      BaseOptions(\n        baseUrl: baseUrl,\n        connectTimeout: Duration(milliseconds: ApiConstants.connectTimeout),\n        receiveTimeout: Duration(milliseconds: ApiConstants.receiveTimeout),\n        sendTimeout: Duration(milliseconds: ApiConstants.sendTimeout),\n        headers: {\n          'Content-Type': ApiConstants.contentType,\n          'Accept': ApiConstants.accept,\n        },\n      ),\n    );\n    \n    _dio.interceptors.addAll([\n      AuthInterceptor(secureStorage: secureStorage),\n      LoggingInterceptor(),\n    ]);\n  }\n  \n  Future<Response<T>> get<T>(\n    String path, {\n    Map<String, dynamic>? queryParameters,\n    Options? options,\n  }) async {\n    try {\n      return await _dio.get<T>(\n        path,\n        queryParameters: queryParameters,\n        options: options,\n      );\n    } on DioException catch (e) {\n      throw _handleDioError(e);\n    }\n  }\n  \n  Future<Response<T>> post<T>(\n    String path, {\n    dynamic data,\n    Map<String, dynamic>? queryParameters,\n    Options? options,\n  }) async {\n    try {\n      return await _dio.post<T>(\n        path,\n        data: data,\n        queryParameters: queryParameters,\n        options: options,\n      );\n    } on DioException catch (e) {\n      throw _handleDioError(e);\n    }\n  }\n  \n  Future<Response<T>> put<T>(\n    String path, {\n    dynamic data,\n    Map<String, dynamic>? queryParameters,\n    Options? options,\n  }) async {\n    try {\n      return await _dio.put<T>(\n        path,\n        data: data,\n        queryParameters: queryParameters,\n        options: options,\n      );\n    } on DioException catch (e) {\n      throw _handleDioError(e);\n    }\n  }\n  \n  Future<Response<T>> delete<T>(\n    String path, {\n    dynamic data,\n    Map<String, dynamic>? queryParameters,\n    Options? options,\n  }) async {\n    try {\n      return await _dio.delete<T>(\n        path,\n        data: data,\n        queryParameters: queryParameters,\n        options: options,\n      );\n    } on DioException catch (e) {\n      throw _handleDioError(e);\n    }\n  }\n  \n  Exception _handleDioError(DioException error) {\n    switch (error.type) {\n      case DioExceptionType.connectionTimeout:\n      case DioExceptionType.sendTimeout:\n      case DioExceptionType.receiveTimeout:\n        return NetworkException(message: 'Connection timeout');\n      case DioExceptionType.badResponse:\n        return _handleStatusCode(error.response?.statusCode, error.response?.data);\n      case DioExceptionType.cancel:\n        return NetworkException(message: 'Request cancelled');\n      case DioExceptionType.connectionError:\n        return NetworkException(message: 'No internet connection');\n      default:\n        return NetworkException(message: error.message ?? 'Unknown error');\n    }\n  }\n  \n  Exception _handleStatusCode(int? statusCode, dynamic data) {\n    final message = data is Map ? data['message'] as String? : null;\n    switch (statusCode) {\n      case 400:\n        return BadRequestException(message: message ?? 'Bad request');\n      case 401:\n        return UnauthorizedException(message: message ?? 'Unauthorized');\n      case 403:\n        return ForbiddenException(message: message ?? 'Forbidden');\n      case 404:\n        return NotFoundException(message: message ?? 'Not found');\n      case 500:\n        return ServerException(message: message ?? 'Internal server error');\n      default:\n        return ServerException(message: message ?? 'Server error: $statusCode');\n    }\n  }\n}\n```\n\nüß™ **VERIFICATION:**\n```bash\nflutter analyze lib/core/network/\ndart format lib/core/network/ --set-exit-if-changed\n```\n- All files pass flutter analyze\n- Code is properly formatted\n- No import errors",
        "epicId": "epic-flutter-foundation",
        "priority": 3,
        "estimatedComplexity": "moderate",
        "dependencies": [
          "epic-flutter-foundation-story-1",
          "epic-flutter-foundation-story-4",
          "epic-flutter-foundation-story-5"
        ],
        "status": "pending",
        "filesToRead": [
          "lib/core/constants/api_constants.dart",
          "lib/core/errors/exceptions.dart",
          "lib/env/env.dart"
        ],
        "filesToModify": [],
        "filesToCreate": [
          "lib/core/network/api_client.dart",
          "lib/core/network/api_interceptor.dart",
          "lib/core/network/network_info.dart"
        ],
        "acceptanceCriteria": [
          "Given ApiClient is instantiated, When making HTTP requests, Then proper headers and interceptors are applied",
          "Given a network error occurs, When Dio throws DioException, Then it is converted to typed custom exception",
          "Given NetworkInfo is used, When checking connectivity, Then it returns correct connected status",
          "Given AuthInterceptor is configured, When token exists in storage, Then Authorization header is added to requests"
        ]
      },
      {
        "id": "epic-flutter-foundation-story-4",
        "title": "Create lib/core/errors/exceptions.dart and lib/core/errors/failures.dart for error handling",
        "description": "Implement custom exceptions and failures for consistent error handling using Result pattern.\n\nüîí **SCOPE BOUNDARY:**\n- You can ONLY create files listed below\n- Creating ANY other file is a scope violation\n\nüìÅ **FILES:**\n- Read: pubspec.yaml (verify dartz is available)\n- Modify: None\n- Create: lib/core/errors/exceptions.dart, lib/core/errors/failures.dart\n\nüîß **PATTERNS TO USE:**\n- Use sealed classes or class hierarchy for exceptions\n- Use Equatable for Failure classes (for testing)\n- Use dartz Either type for Result pattern\n- All exceptions should extend a base AppException\n\n‚ö†Ô∏è **ANTI-PATTERNS TO AVOID:**\n- DO NOT use generic Exception - use typed exceptions\n- DO NOT create failures without equatable implementation\n- DO NOT mix exceptions and failures - exceptions for data layer, failures for domain\n\nüéØ **FUNCTIONAL REQUIREMENTS:**\n\n**lib/core/errors/exceptions.dart:**\n```dart\n/// Base exception class for all app exceptions\nabstract class AppException implements Exception {\n  final String message;\n  final String? code;\n  final dynamic originalError;\n  \n  const AppException({\n    required this.message,\n    this.code,\n    this.originalError,\n  });\n  \n  @override\n  String toString() => 'AppException: $message (code: $code)';\n}\n\n/// Network-related exceptions\nclass NetworkException extends AppException {\n  const NetworkException({\n    required super.message,\n    super.code,\n    super.originalError,\n  });\n}\n\n/// Server returned an error response\nclass ServerException extends AppException {\n  final int? statusCode;\n  \n  const ServerException({\n    required super.message,\n    this.statusCode,\n    super.code,\n    super.originalError,\n  });\n}\n\n/// 400 Bad Request\nclass BadRequestException extends AppException {\n  const BadRequestException({\n    required super.message,\n    super.code,\n    super.originalError,\n  });\n}\n\n/// 401 Unauthorized\nclass UnauthorizedException extends AppException {\n  const UnauthorizedException({\n    required super.message,\n    super.code,\n    super.originalError,\n  });\n}\n\n/// 403 Forbidden\nclass ForbiddenException extends AppException {\n  const ForbiddenException({\n    required super.message,\n    super.code,\n    super.originalError,\n  });\n}\n\n/// 404 Not Found\nclass NotFoundException extends AppException {\n  const NotFoundException({\n    required super.message,\n    super.code,\n    super.originalError,\n  });\n}\n\n/// Cache/Storage exceptions\nclass CacheException extends AppException {\n  const CacheException({\n    required super.message,\n    super.code,\n    super.originalError,\n  });\n}\n\n/// Validation exceptions\nclass ValidationException extends AppException {\n  final Map<String, List<String>>? fieldErrors;\n  \n  const ValidationException({\n    required super.message,\n    this.fieldErrors,\n    super.code,\n    super.originalError,\n  });\n}\n```\n\n**lib/core/errors/failures.dart:**\n```dart\nimport 'package:dartz/dartz.dart';\n\n/// Type alias for Either with Failure\ntypedef Result<T> = Either<Failure, T>;\n\n/// Base failure class for domain layer errors\nabstract class Failure {\n  final String message;\n  final String? code;\n  \n  const Failure({\n    required this.message,\n    this.code,\n  });\n  \n  @override\n  bool operator ==(Object other) =>\n      identical(this, other) ||\n      other is Failure &&\n          runtimeType == other.runtimeType &&\n          message == other.message &&\n          code == other.code;\n  \n  @override\n  int get hashCode => message.hashCode ^ (code?.hashCode ?? 0);\n  \n  @override\n  String toString() => 'Failure: $message (code: $code)';\n}\n\n/// Network-related failures\nclass NetworkFailure extends Failure {\n  const NetworkFailure({required super.message, super.code});\n}\n\n/// Server-related failures\nclass ServerFailure extends Failure {\n  final int? statusCode;\n  \n  const ServerFailure({\n    required super.message,\n    this.statusCode,\n    super.code,\n  });\n  \n  @override\n  bool operator ==(Object other) =>\n      identical(this, other) ||\n      super == other &&\n          other is ServerFailure &&\n          statusCode == other.statusCode;\n  \n  @override\n  int get hashCode => super.hashCode ^ (statusCode?.hashCode ?? 0);\n}\n\n/// Authentication failures\nclass AuthFailure extends Failure {\n  const AuthFailure({required super.message, super.code});\n}\n\n/// Cache/Storage failures\nclass CacheFailure extends Failure {\n  const CacheFailure({required super.message, super.code});\n}\n\n/// Validation failures\nclass ValidationFailure extends Failure {\n  final Map<String, List<String>>? fieldErrors;\n  \n  const ValidationFailure({\n    required super.message,\n    this.fieldErrors,\n    super.code,\n  });\n}\n\n/// Unknown/unexpected failures\nclass UnexpectedFailure extends Failure {\n  const UnexpectedFailure({super.message = 'An unexpected error occurred', super.code});\n}\n\n/// Extension methods for Result handling\nextension ResultExtensions<T> on Result<T> {\n  T getOrThrow() => fold(\n    (failure) => throw Exception(failure.message),\n    (value) => value,\n  );\n  \n  T? getOrNull() => fold(\n    (failure) => null,\n    (value) => value,\n  );\n  \n  Result<R> mapSuccess<R>(R Function(T value) mapper) => fold(\n    (failure) => Left(failure),\n    (value) => Right(mapper(value)),\n  );\n}\n```\n\nüß™ **VERIFICATION:**\n```bash\nflutter analyze lib/core/errors/\ndart format lib/core/errors/ --set-exit-if-changed\n```\n- All files pass flutter analyze\n- Code is properly formatted\n- No import errors",
        "epicId": "epic-flutter-foundation",
        "priority": 2,
        "estimatedComplexity": "simple",
        "dependencies": [
          "epic-flutter-foundation-story-1"
        ],
        "status": "pending",
        "filesToRead": [
          "pubspec.yaml"
        ],
        "filesToModify": [],
        "filesToCreate": [
          "lib/core/errors/exceptions.dart",
          "lib/core/errors/failures.dart"
        ],
        "acceptanceCriteria": [
          "Given AppException base class exists, When creating typed exceptions, Then all inherit message and code properties",
          "Given Failure classes exist, When comparing two failures with same properties, Then they are equal",
          "Given Result type alias exists, When using Either pattern, Then can fold over success/failure cases",
          "Given ResultExtensions exist, When calling getOrNull on failure, Then returns null without throwing"
        ]
      },
      {
        "id": "epic-flutter-foundation-story-5",
        "title": "Create lib/env/env.dart and lib/env/env.g.dart for environment configuration with envied",
        "description": "Set up environment configuration using envied for secure API URL and environment-specific settings.\n\nüîí **SCOPE BOUNDARY:**\n- You can ONLY create files listed below\n- Creating ANY other file is a scope violation\n\nüìÅ **FILES:**\n- Read: pubspec.yaml (verify envied is available)\n- Modify: None\n- Create: lib/env/env.dart, lib/env/env.g.dart\n\nüîß **PATTERNS TO USE:**\n- Use @Envied annotation for environment config\n- Use @EnviedField for individual fields\n- Create both dev and prod environment classes\n- Provide fallback values for development\n\n‚ö†Ô∏è **ANTI-PATTERNS TO AVOID:**\n- DO NOT commit real API keys to env.dart\n- DO NOT hardcode production URLs in code\n- DO NOT make Env class instantiable\n\nüéØ **FUNCTIONAL REQUIREMENTS:**\n\n**lib/env/env.dart:**\n```dart\nimport 'package:envied/envied.dart';\n\npart 'env.g.dart';\n\n/// Environment configuration using envied\n/// \n/// To generate env.g.dart, create a .env file in project root:\n/// ```\n/// API_URL=http://localhost:3000\n/// API_KEY=your_api_key_here\n/// ```\n/// Then run: flutter pub run build_runner build\n@Envied(path: '.env', obfuscate: true)\nabstract class Env {\n  /// Base URL for API requests\n  /// Defaults to localhost for development\n  @EnviedField(\n    varName: 'API_URL',\n    defaultValue: 'http://localhost:3000',\n  )\n  static String get apiUrl => _Env.apiUrl;\n  \n  /// API Key for authentication (if needed)\n  @EnviedField(\n    varName: 'API_KEY',\n    defaultValue: '',\n    obfuscate: true,\n  )\n  static String get apiKey => _Env.apiKey;\n  \n  /// Environment name (development, staging, production)\n  @EnviedField(\n    varName: 'ENVIRONMENT',\n    defaultValue: 'development',\n  )\n  static String get environment => _Env.environment;\n  \n  /// Whether debug mode is enabled\n  @EnviedField(\n    varName: 'DEBUG_MODE',\n    defaultValue: 'true',\n  )\n  static String get debugModeString => _Env.debugModeString;\n  \n  /// Parsed debug mode as boolean\n  static bool get debugMode => debugModeString.toLowerCase() == 'true';\n  \n  /// Check if running in production\n  static bool get isProduction => environment == 'production';\n  \n  /// Check if running in development\n  static bool get isDevelopment => environment == 'development';\n  \n  /// Check if running in staging\n  static bool get isStaging => environment == 'staging';\n}\n```\n\n**lib/env/env.g.dart:**\n```dart\n// GENERATED CODE - DO NOT MODIFY BY HAND\n// This is a placeholder that will be regenerated by build_runner\n\npart of 'env.dart';\n\nclass _Env {\n  static const String apiUrl = 'http://localhost:3000';\n  static const String apiKey = '';\n  static const String environment = 'development';\n  static const String debugModeString = 'true';\n}\n```\n\n**IMPORTANT:** Also create a .env.example file in the project root for reference:\n```\n# Environment Configuration\n# Copy this file to .env and fill in your values\n\n# API Configuration\nAPI_URL=http://localhost:3000\nAPI_KEY=\n\n# Environment (development, staging, production)\nENVIRONMENT=development\n\n# Debug Mode\nDEBUG_MODE=true\n```\n\nüß™ **VERIFICATION:**\n```bash\nflutter analyze lib/env/\ndart format lib/env/ --set-exit-if-changed\n# After creating .env file:\nflutter pub run build_runner build --delete-conflicting-outputs\n```\n- All files pass flutter analyze\n- Code is properly formatted\n- Env.apiUrl returns localhost URL by default",
        "epicId": "epic-flutter-foundation",
        "priority": 2,
        "estimatedComplexity": "simple",
        "dependencies": [
          "epic-flutter-foundation-story-1"
        ],
        "status": "pending",
        "filesToRead": [
          "pubspec.yaml"
        ],
        "filesToModify": [],
        "filesToCreate": [
          "lib/env/env.dart",
          "lib/env/env.g.dart"
        ],
        "acceptanceCriteria": [
          "Given env.dart is created with @Envied annotation, When accessing Env.apiUrl, Then returns configured or default URL",
          "Given .env file exists with API_URL, When build_runner runs, Then env.g.dart is generated with correct values",
          "Given Env class has helper methods, When checking Env.isDevelopment, Then returns true in dev environment",
          "Given obfuscate is true for apiKey, When generated, Then value is obfuscated in env.g.dart"
        ]
      },
      {
        "id": "epic-flutter-foundation-story-6",
        "title": "Create lib/core/utils/ and lib/core/extensions/ files and update lib/main.dart with DI initialization",
        "description": "Implement utility classes (Logger, Validators), extensions, and integrate DI into main.dart.\n\nüîí **SCOPE BOUNDARY:**\n- You can ONLY create/modify files listed below\n- Creating ANY other file is a scope violation\n\nüìÅ **FILES:**\n- Read: lib/main.dart, lib/core/di/injection_container.dart\n- Modify: lib/main.dart\n- Create: lib/core/utils/logger.dart, lib/core/utils/validators.dart, lib/core/extensions/context_extensions.dart, lib/core/extensions/string_extensions.dart\n\nüîß **PATTERNS TO USE:**\n- Use extension methods for clean API\n- Use static methods for Logger utility\n- Validators should return bool or validation message\n- Initialize DI in main() before runApp()\n\n‚ö†Ô∏è **ANTI-PATTERNS TO AVOID:**\n- DO NOT use print() - use Logger class\n- DO NOT create widget extensions that rebuild unnecessarily\n- DO NOT make Logger instantiable - use static methods\n- DO NOT forget to call initializeDependencies() in main()\n\nüéØ **FUNCTIONAL REQUIREMENTS:**\n\n**lib/core/utils/logger.dart:**\n```dart\nimport 'dart:developer' as developer;\nimport 'package:flutter/foundation.dart';\nimport '../../env/env.dart';\n\n/// Centralized logging utility\nabstract class Logger {\n  Logger._();\n  \n  static void debug(String message, {String? tag, Object? error, StackTrace? stackTrace}) {\n    if (Env.debugMode) {\n      _log('DEBUG', message, tag: tag, error: error, stackTrace: stackTrace);\n    }\n  }\n  \n  static void info(String message, {String? tag}) {\n    _log('INFO', message, tag: tag);\n  }\n  \n  static void warning(String message, {String? tag, Object? error}) {\n    _log('WARNING', message, tag: tag, error: error);\n  }\n  \n  static void error(String message, {String? tag, Object? error, StackTrace? stackTrace}) {\n    _log('ERROR', message, tag: tag, error: error, stackTrace: stackTrace);\n  }\n  \n  static void _log(\n    String level,\n    String message, {\n    String? tag,\n    Object? error,\n    StackTrace? stackTrace,\n  }) {\n    final timestamp = DateTime.now().toIso8601String();\n    final tagStr = tag != null ? '[$tag]' : '';\n    final fullMessage = '$timestamp [$level]$tagStr $message';\n    \n    if (kDebugMode) {\n      developer.log(\n        fullMessage,\n        name: tag ?? 'AppPasos',\n        error: error,\n        stackTrace: stackTrace,\n      );\n    }\n    \n    // In production, could send to crash reporting service\n    if (level == 'ERROR' && Env.isProduction) {\n      // TODO: Send to Crashlytics/Sentry in future\n    }\n  }\n}\n```\n\n**lib/core/utils/validators.dart:**\n```dart\nimport '../constants/app_constants.dart';\n\n/// Validation utility class\nabstract class Validators {\n  Validators._();\n  \n  /// Email validation\n  static String? email(String? value) {\n    if (value == null || value.isEmpty) {\n      return 'Email is required';\n    }\n    final emailRegex = RegExp(\n      r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$',\n    );\n    if (!emailRegex.hasMatch(value)) {\n      return 'Please enter a valid email';\n    }\n    return null;\n  }\n  \n  /// Password validation\n  static String? password(String? value) {\n    if (value == null || value.isEmpty) {\n      return 'Password is required';\n    }\n    if (value.length < AppConstants.minPasswordLength) {\n      return 'Password must be at least ${AppConstants.minPasswordLength} characters';\n    }\n    if (value.length > AppConstants.maxPasswordLength) {\n      return 'Password must be less than ${AppConstants.maxPasswordLength} characters';\n    }\n    return null;\n  }\n  \n  /// Password with complexity requirements\n  static String? passwordStrong(String? value) {\n    final basicError = password(value);\n    if (basicError != null) return basicError;\n    \n    if (!RegExp(r'[A-Z]').hasMatch(value!)) {\n      return 'Password must contain at least one uppercase letter';\n    }\n    if (!RegExp(r'[a-z]').hasMatch(value)) {\n      return 'Password must contain at least one lowercase letter';\n    }\n    if (!RegExp(r'[0-9]').hasMatch(value)) {\n      return 'Password must contain at least one number';\n    }\n    return null;\n  }\n  \n  /// Username validation\n  static String? username(String? value) {\n    if (value == null || value.isEmpty) {\n      return 'Username is required';\n    }\n    if (value.length < AppConstants.minUsernameLength) {\n      return 'Username must be at least ${AppConstants.minUsernameLength} characters';\n    }\n    if (value.length > AppConstants.maxUsernameLength) {\n      return 'Username must be less than ${AppConstants.maxUsernameLength} characters';\n    }\n    if (!RegExp(r'^[a-zA-Z0-9_]+$').hasMatch(value)) {\n      return 'Username can only contain letters, numbers, and underscores';\n    }\n    return null;\n  }\n  \n  /// Required field validation\n  static String? required(String? value, [String fieldName = 'This field']) {\n    if (value == null || value.trim().isEmpty) {\n      return '$fieldName is required';\n    }\n    return null;\n  }\n  \n  /// Phone number validation (basic)\n  static String? phone(String? value) {\n    if (value == null || value.isEmpty) {\n      return 'Phone number is required';\n    }\n    final phoneRegex = RegExp(r'^\\+?[0-9]{10,15}$');\n    if (!phoneRegex.hasMatch(value.replaceAll(RegExp(r'[\\s-]'), ''))) {\n      return 'Please enter a valid phone number';\n    }\n    return null;\n  }\n  \n  /// Confirm password validation\n  static String? confirmPassword(String? value, String? original) {\n    if (value == null || value.isEmpty) {\n      return 'Please confirm your password';\n    }\n    if (value != original) {\n      return 'Passwords do not match';\n    }\n    return null;\n  }\n}\n```\n\n**lib/core/extensions/context_extensions.dart:**\n```dart\nimport 'package:flutter/material.dart';\n\n/// Extension methods for BuildContext\nextension ContextExtensions on BuildContext {\n  /// Get current theme\n  ThemeData get theme => Theme.of(this);\n  \n  /// Get current color scheme\n  ColorScheme get colorScheme => theme.colorScheme;\n  \n  /// Get current text theme\n  TextTheme get textTheme => theme.textTheme;\n  \n  /// Get screen size\n  Size get screenSize => MediaQuery.sizeOf(this);\n  \n  /// Get screen width\n  double get screenWidth => screenSize.width;\n  \n  /// Get screen height\n  double get screenHeight => screenSize.height;\n  \n  /// Get device padding (safe area)\n  EdgeInsets get padding => MediaQuery.paddingOf(this);\n  \n  /// Get view insets (keyboard, etc.)\n  EdgeInsets get viewInsets => MediaQuery.viewInsetsOf(this);\n  \n  /// Check if keyboard is visible\n  bool get isKeyboardVisible => viewInsets.bottom > 0;\n  \n  /// Check if device is in portrait mode\n  bool get isPortrait => screenHeight > screenWidth;\n  \n  /// Check if device is in landscape mode\n  bool get isLandscape => screenWidth > screenHeight;\n  \n  /// Check if device is a tablet (width > 600)\n  bool get isTablet => screenWidth > 600;\n  \n  /// Show snackbar\n  void showSnackBar(String message, {Duration? duration, SnackBarAction? action}) {\n    ScaffoldMessenger.of(this).showSnackBar(\n      SnackBar(\n        content: Text(message),\n        duration: duration ?? const Duration(seconds: 3),\n        action: action,\n      ),\n    );\n  }\n  \n  /// Show error snackbar\n  void showErrorSnackBar(String message) {\n    ScaffoldMessenger.of(this).showSnackBar(\n      SnackBar(\n        content: Text(message),\n        backgroundColor: colorScheme.error,\n        duration: const Duration(seconds: 4),\n      ),\n    );\n  }\n  \n  /// Show success snackbar\n  void showSuccessSnackBar(String message) {\n    ScaffoldMessenger.of(this).showSnackBar(\n      SnackBar(\n        content: Text(message),\n        backgroundColor: Colors.green,\n        duration: const Duration(seconds: 3),\n      ),\n    );\n  }\n  \n  /// Hide current snackbar\n  void hideSnackBar() {\n    ScaffoldMessenger.of(this).hideCurrentSnackBar();\n  }\n  \n  /// Unfocus current focus (dismiss keyboard)\n  void unfocus() {\n    FocusScope.of(this).unfocus();\n  }\n}\n```\n\n**lib/core/extensions/string_extensions.dart:**\n```dart\n/// Extension methods for String\nextension StringExtensions on String {\n  /// Capitalize first letter\n  String get capitalize {\n    if (isEmpty) return this;\n    return '${this[0].toUpperCase()}${substring(1)}';\n  }\n  \n  /// Capitalize first letter of each word\n  String get titleCase {\n    if (isEmpty) return this;\n    return split(' ').map((word) => word.capitalize).join(' ');\n  }\n  \n  /// Check if string is valid email\n  bool get isValidEmail {\n    return RegExp(\n      r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$',\n    ).hasMatch(this);\n  }\n  \n  /// Check if string contains only numbers\n  bool get isNumeric => RegExp(r'^[0-9]+$').hasMatch(this);\n  \n  /// Check if string contains only letters\n  bool get isAlpha => RegExp(r'^[a-zA-Z]+$').hasMatch(this);\n  \n  /// Check if string contains only letters and numbers\n  bool get isAlphanumeric => RegExp(r'^[a-zA-Z0-9]+$').hasMatch(this);\n  \n  /// Remove all whitespace\n  String get removeWhitespace => replaceAll(RegExp(r'\\s+'), '');\n  \n  /// Truncate string to max length with ellipsis\n  String truncate(int maxLength, {String suffix = '...'}) {\n    if (length <= maxLength) return this;\n    return '${substring(0, maxLength - suffix.length)}$suffix';\n  }\n  \n  /// Convert to snake_case\n  String get toSnakeCase {\n    return replaceAllMapped(\n      RegExp(r'[A-Z]'),\n      (match) => '_${match.group(0)!.toLowerCase()}',\n    ).replaceFirst(RegExp(r'^_'), '');\n  }\n  \n  /// Convert to camelCase\n  String get toCamelCase {\n    final words = split(RegExp(r'[_\\s-]+'));\n    if (words.isEmpty) return this;\n    return words.first.toLowerCase() +\n        words.skip(1).map((w) => w.capitalize).join();\n  }\n  \n  /// Parse to int or return null\n  int? get toIntOrNull => int.tryParse(this);\n  \n  /// Parse to double or return null\n  double? get toDoubleOrNull => double.tryParse(this);\n  \n  /// Check if string is blank (empty or only whitespace)\n  bool get isBlank => trim().isEmpty;\n  \n  /// Check if string is not blank\n  bool get isNotBlank => !isBlank;\n}\n\n/// Extension for nullable String\nextension NullableStringExtensions on String? {\n  /// Return empty string if null\n  String get orEmpty => this ?? '';\n  \n  /// Check if null or empty\n  bool get isNullOrEmpty => this == null || this!.isEmpty;\n  \n  /// Check if not null and not empty\n  bool get isNotNullOrEmpty => !isNullOrEmpty;\n}\n```\n\n**lib/main.dart (MODIFY):**\n```dart\nimport 'package:flutter/material.dart';\nimport 'core/di/injection_container.dart';\nimport 'core/utils/logger.dart';\n\nvoid main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  \n  // Initialize dependency injection\n  await initializeDependencies();\n  \n  Logger.info('App starting...', tag: 'Main');\n  \n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'App Pasos',\n      theme: ThemeData(\n        colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple),\n        useMaterial3: true,\n      ),\n      home: const MyHomePage(title: 'App Pasos'),\n    );\n  }\n}\n\nclass MyHomePage extends StatefulWidget {\n  const MyHomePage({super.key, required this.title});\n\n  final String title;\n\n  @override\n  State<MyHomePage> createState() => _MyHomePageState();\n}\n\nclass _MyHomePageState extends State<MyHomePage> {\n  int _counter = 0;\n\n  void _incrementCounter() {\n    setState(() {\n      _counter++;\n    });\n    Logger.debug('Counter incremented to $_counter', tag: 'HomePage');\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        backgroundColor: Theme.of(context).colorScheme.inversePrimary,\n        title: Text(widget.title),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            const Text(\n              'You have pushed the button this many times:',\n            ),\n            Text(\n              '$_counter',\n              style: Theme.of(context).textTheme.headlineMedium,\n            ),\n          ],\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: _incrementCounter,\n        tooltip: 'Increment',\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}\n```\n\nüß™ **VERIFICATION:**\n```bash\nflutter analyze lib/core/utils/\nflutter analyze lib/core/extensions/\nflutter analyze lib/main.dart\ndart format lib/ --set-exit-if-changed\nflutter run -d chrome --web-port=8080 &\nsleep 10\ncurl -s http://localhost:8080 | head -20\n```\n- All files pass flutter analyze\n- Code is properly formatted\n- App starts without errors\n- Logger outputs to console in debug mode",
        "epicId": "epic-flutter-foundation",
        "priority": 3,
        "estimatedComplexity": "moderate",
        "dependencies": [
          "epic-flutter-foundation-story-1",
          "epic-flutter-foundation-story-2",
          "epic-flutter-foundation-story-5"
        ],
        "status": "pending",
        "filesToRead": [
          "lib/main.dart",
          "lib/core/di/injection_container.dart",
          "lib/env/env.dart"
        ],
        "filesToModify": [
          "lib/main.dart"
        ],
        "filesToCreate": [
          "lib/core/utils/logger.dart",
          "lib/core/utils/validators.dart",
          "lib/core/extensions/context_extensions.dart",
          "lib/core/extensions/string_extensions.dart"
        ],
        "acceptanceCriteria": [
          "Given Logger utility exists, When calling Logger.debug in debug mode, Then message is logged to console",
          "Given Validators utility exists, When validating email 'test@example.com', Then returns null (valid)",
          "Given Validators utility exists, When validating email 'invalid', Then returns error message",
          "Given context extensions exist, When using context.screenWidth, Then returns correct screen width",
          "Given string extensions exist, When calling 'hello'.capitalize, Then returns 'Hello'",
          "Given main.dart is updated, When app starts, Then initializeDependencies is called before runApp"
        ]
      }
    ]
  }
}