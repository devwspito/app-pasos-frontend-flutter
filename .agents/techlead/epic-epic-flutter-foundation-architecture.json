{
  "_metadata": {
    "agentType": "techlead",
    "taskId": "439c1f89078ffbdbf91e379f",
    "timestamp": "2026-01-25T22:32:27.689Z",
    "phase": "techlead",
    "epicId": "epic-flutter-foundation",
    "savedAt": "2026-01-25T22:32:27.690Z",
    "version": "1.0"
  },
  "data": {
    "epicId": "epic-flutter-foundation",
    "storiesCount": 5,
    "architecture": "## Flutter Foundation Architecture\n\n### Pattern: Feature-based Architecture with Core Utilities\n\n```\nlib/\n‚îú‚îÄ‚îÄ main.dart                 # Entry point with initialization\n‚îú‚îÄ‚îÄ app.dart                  # Root App widget with providers\n‚îî‚îÄ‚îÄ core/\n    ‚îú‚îÄ‚îÄ constants/            # Static values and configuration\n    ‚îÇ   ‚îú‚îÄ‚îÄ app_constants.dart\n    ‚îÇ   ‚îî‚îÄ‚îÄ api_endpoints.dart\n    ‚îú‚îÄ‚îÄ config/               # Environment and app configuration\n    ‚îÇ   ‚îú‚îÄ‚îÄ app_config.dart\n    ‚îÇ   ‚îî‚îÄ‚îÄ environment.dart\n    ‚îú‚îÄ‚îÄ utils/                # Utility classes\n    ‚îÇ   ‚îú‚îÄ‚îÄ logger.dart\n    ‚îÇ   ‚îî‚îÄ‚îÄ validators.dart\n    ‚îú‚îÄ‚îÄ errors/               # Exception handling\n    ‚îÇ   ‚îú‚îÄ‚îÄ app_exceptions.dart\n    ‚îÇ   ‚îî‚îÄ‚îÄ error_handler.dart\n    ‚îú‚îÄ‚îÄ network/              # HTTP client layer\n    ‚îÇ   ‚îú‚îÄ‚îÄ dio_client.dart\n    ‚îÇ   ‚îú‚îÄ‚îÄ api_interceptor.dart\n    ‚îÇ   ‚îî‚îÄ‚îÄ network_info.dart\n    ‚îî‚îÄ‚îÄ storage/              # Data persistence\n        ‚îú‚îÄ‚îÄ secure_storage.dart\n        ‚îî‚îÄ‚îÄ local_storage.dart\n```\n\n### SOLID Principles Applied:\n\n1. **Single Responsibility**: Each class has one purpose (DioClient for HTTP, TokenStorage for tokens, etc.)\n2. **Open/Closed**: Abstract classes (SecureStorage, LocalStorage, NetworkInfo) allow extension without modification\n3. **Liskov Substitution**: All storage implementations can be substituted for their abstract types\n4. **Interface Segregation**: Small focused interfaces (SecureStorage vs LocalStorage)\n5. **Dependency Inversion**: High-level modules depend on abstractions (TokenStorage depends on SecureStorage interface)\n\n### Dependency Graph:\n\n```\nstory-1 (pubspec.yaml)\n    ‚îÇ\n    ‚îú‚îÄ‚îÄ story-2 (constants + config + utils)\n    ‚îú‚îÄ‚îÄ story-3 (network layer)\n    ‚îî‚îÄ‚îÄ story-4 (storage layer)\n            ‚îÇ\n            ‚îî‚îÄ‚îÄ story-5 (errors + app integration)\n```\n\nStories 2, 3, 4 can execute in parallel after story-1 completes.\nStory-5 integrates everything and runs last.\n\n### Setup Commands:\n```bash\nflutter pub get\n```\n\n### Verification Commands:\n```bash\nflutter analyze       # Type checking and linting\nflutter test          # Run unit tests\ndart format lib/      # Code formatting\nflutter run           # Run the app\n```",
    "stories": [
      {
        "id": "epic-flutter-foundation-story-1",
        "title": "Configure pubspec.yaml with provider, dio, go_router, flutter_secure_storage and required packages",
        "description": "Add all required dependencies to pubspec.yaml for the Flutter foundation.\n\nüîí **SCOPE BOUNDARY:**\n- You can ONLY modify pubspec.yaml\n- DO NOT create any Dart files in this story\n\nüìÅ **FILES:**\n- Read: pubspec.yaml (current state)\n- Modify: pubspec.yaml\n- Create: NONE\n\nüîß **IMPLEMENTATION DETAILS:**\n\nAdd to `dependencies:` section:\n```yaml\n  provider: ^6.1.2\n  dio: ^5.4.0\n  go_router: ^14.2.0\n  flutter_secure_storage: ^9.2.2\n  connectivity_plus: ^6.0.3\n  shared_preferences: ^2.2.3\n  logger: ^2.2.0\n  equatable: ^2.0.5\n  intl: ^0.19.0\n```\n\nAdd to `dev_dependencies:` section:\n```yaml\n  mockito: ^5.4.4\n  build_runner: ^2.4.9\n```\n\n‚ö†Ô∏è **ANTI-PATTERNS TO AVOID:**\n- DO NOT add firebase_messaging yet (separate epic)\n- DO NOT add fl_chart yet (separate epic)\n- DO NOT add web_socket_channel yet (separate epic)\n- DO NOT use caret (^) versions that are too old\n- DO NOT remove existing dependencies (flutter, cupertino_icons, flutter_lints)\n\nüéØ **FUNCTIONAL REQUIREMENTS:**\n- All version numbers must be compatible with Dart SDK ^3.10.7\n- Maintain existing flutter and dev_dependencies sections\n- Keep publish_to: 'none' setting\n\nüß™ **VERIFICATION:**\n```bash\nflutter pub get\nflutter analyze\n```\n- Verify: No dependency resolution errors\n- Verify: All packages download successfully",
        "epicId": "epic-flutter-foundation",
        "priority": 1,
        "estimatedComplexity": "simple",
        "dependencies": [],
        "status": "pending",
        "filesToRead": [
          "pubspec.yaml"
        ],
        "filesToModify": [
          "pubspec.yaml"
        ],
        "filesToCreate": [],
        "acceptanceCriteria": [
          "Given pubspec.yaml, When flutter pub get runs, Then all dependencies resolve without errors",
          "Given the updated pubspec.yaml, When flutter analyze runs, Then no pubspec-related warnings appear",
          "Given the dependencies list, When checking versions, Then all versions are compatible with Dart SDK ^3.10.7"
        ]
      },
      {
        "id": "epic-flutter-foundation-story-2",
        "title": "Create lib/core/constants/, lib/core/config/, and lib/core/utils/ with foundation files",
        "description": "Create the core directory structure with constants, configuration, and utility files.\n\nüîí **SCOPE BOUNDARY:**\n- You can ONLY create the 6 files listed below\n- DO NOT create network, storage, or error files (other stories)\n- DO NOT modify main.dart or create app.dart (story-5)\n\nüìÅ **FILES:**\n- Read: pubspec.yaml, lib/main.dart\n- Modify: NONE\n- Create:\n  - lib/core/constants/app_constants.dart\n  - lib/core/constants/api_endpoints.dart\n  - lib/core/config/app_config.dart\n  - lib/core/config/environment.dart\n  - lib/core/utils/logger.dart\n  - lib/core/utils/validators.dart\n\nüîß **IMPLEMENTATION DETAILS:**\n\n**app_constants.dart:**\n```dart\nclass AppConstants {\n  static const String appName = 'App Pasos';\n  static const String appVersion = '1.0.0';\n  static const int connectionTimeout = 30000; // 30 seconds\n  static const int receiveTimeout = 30000;\n  static const int maxRetries = 3;\n  \n  // Storage keys\n  static const String accessTokenKey = 'access_token';\n  static const String refreshTokenKey = 'refresh_token';\n  static const String userDataKey = 'user_data';\n  \n  // Prevent instantiation\n  AppConstants._();\n}\n```\n\n**api_endpoints.dart:**\n```dart\nclass ApiEndpoints {\n  static const String baseUrl = 'https://api.apppasos.com';\n  static const String apiVersion = '/api/v1';\n  \n  // Auth endpoints\n  static const String login = '/auth/login';\n  static const String register = '/auth/register';\n  static const String refreshToken = '/auth/refresh';\n  static const String logout = '/auth/logout';\n  \n  // User endpoints\n  static const String userProfile = '/users/profile';\n  static const String updateProfile = '/users/profile';\n  \n  // Health check\n  static const String health = '/health';\n  \n  static String fullUrl(String endpoint) => '$baseUrl$apiVersion$endpoint';\n  \n  ApiEndpoints._();\n}\n```\n\n**environment.dart:**\n```dart\nenum Environment { development, staging, production }\n\nclass EnvironmentConfig {\n  final Environment environment;\n  final String baseUrl;\n  final bool enableLogging;\n  final bool enableCrashReporting;\n  \n  const EnvironmentConfig({\n    required this.environment,\n    required this.baseUrl,\n    this.enableLogging = true,\n    this.enableCrashReporting = false,\n  });\n  \n  static const EnvironmentConfig development = EnvironmentConfig(\n    environment: Environment.development,\n    baseUrl: 'http://localhost:3000/api/v1',\n    enableLogging: true,\n    enableCrashReporting: false,\n  );\n  \n  static const EnvironmentConfig staging = EnvironmentConfig(\n    environment: Environment.staging,\n    baseUrl: 'https://staging-api.apppasos.com/api/v1',\n    enableLogging: true,\n    enableCrashReporting: true,\n  );\n  \n  static const EnvironmentConfig production = EnvironmentConfig(\n    environment: Environment.production,\n    baseUrl: 'https://api.apppasos.com/api/v1',\n    enableLogging: false,\n    enableCrashReporting: true,\n  );\n}\n```\n\n**app_config.dart:**\n```dart\nimport 'environment.dart';\n\nclass AppConfig {\n  static late EnvironmentConfig _config;\n  \n  static void initialize(EnvironmentConfig config) {\n    _config = config;\n  }\n  \n  static EnvironmentConfig get current => _config;\n  static String get baseUrl => _config.baseUrl;\n  static bool get enableLogging => _config.enableLogging;\n  static bool get enableCrashReporting => _config.enableCrashReporting;\n  static Environment get environment => _config.environment;\n  \n  static bool get isDevelopment => _config.environment == Environment.development;\n  static bool get isStaging => _config.environment == Environment.staging;\n  static bool get isProduction => _config.environment == Environment.production;\n}\n```\n\n**logger.dart:**\n```dart\nimport 'package:logger/logger.dart' as log;\nimport '../config/app_config.dart';\n\nclass AppLogger {\n  static late log.Logger _logger;\n  static bool _initialized = false;\n  \n  static void initialize() {\n    if (_initialized) return;\n    \n    _logger = log.Logger(\n      printer: log.PrettyPrinter(\n        methodCount: 2,\n        errorMethodCount: 8,\n        lineLength: 120,\n        colors: true,\n        printEmojis: true,\n        dateTimeFormat: log.DateTimeFormat.onlyTimeAndSinceStart,\n      ),\n      level: AppConfig.enableLogging ? log.Level.debug : log.Level.off,\n    );\n    _initialized = true;\n  }\n  \n  static void debug(String message, [dynamic error, StackTrace? stackTrace]) {\n    if (_initialized) _logger.d(message, error: error, stackTrace: stackTrace);\n  }\n  \n  static void info(String message, [dynamic error, StackTrace? stackTrace]) {\n    if (_initialized) _logger.i(message, error: error, stackTrace: stackTrace);\n  }\n  \n  static void warning(String message, [dynamic error, StackTrace? stackTrace]) {\n    if (_initialized) _logger.w(message, error: error, stackTrace: stackTrace);\n  }\n  \n  static void error(String message, [dynamic error, StackTrace? stackTrace]) {\n    if (_initialized) _logger.e(message, error: error, stackTrace: stackTrace);\n  }\n}\n```\n\n**validators.dart:**\n```dart\nclass Validators {\n  static final RegExp _emailRegex = RegExp(\n    r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$',\n  );\n  \n  static final RegExp _phoneRegex = RegExp(\n    r'^\\+?[1-9]\\d{1,14}$',\n  );\n  \n  static String? validateEmail(String? value) {\n    if (value == null || value.isEmpty) {\n      return 'Email is required';\n    }\n    if (!_emailRegex.hasMatch(value)) {\n      return 'Please enter a valid email address';\n    }\n    return null;\n  }\n  \n  static String? validatePassword(String? value) {\n    if (value == null || value.isEmpty) {\n      return 'Password is required';\n    }\n    if (value.length < 8) {\n      return 'Password must be at least 8 characters';\n    }\n    if (!value.contains(RegExp(r'[A-Z]'))) {\n      return 'Password must contain at least one uppercase letter';\n    }\n    if (!value.contains(RegExp(r'[0-9]'))) {\n      return 'Password must contain at least one number';\n    }\n    return null;\n  }\n  \n  static String? validatePhone(String? value) {\n    if (value == null || value.isEmpty) {\n      return 'Phone number is required';\n    }\n    if (!_phoneRegex.hasMatch(value.replaceAll(RegExp(r'[\\s\\-()]'), ''))) {\n      return 'Please enter a valid phone number';\n    }\n    return null;\n  }\n  \n  static String? validateRequired(String? value, String fieldName) {\n    if (value == null || value.trim().isEmpty) {\n      return '$fieldName is required';\n    }\n    return null;\n  }\n  \n  static String? validateMinLength(String? value, int minLength, String fieldName) {\n    if (value == null || value.length < minLength) {\n      return '$fieldName must be at least $minLength characters';\n    }\n    return null;\n  }\n  \n  Validators._();\n}\n```\n\n‚ö†Ô∏è **ANTI-PATTERNS TO AVOID:**\n- DO NOT use hardcoded strings without constants\n- DO NOT create singleton instances with mutable state\n- DO NOT import from network/, storage/, or errors/ directories\n- DO NOT leave TODO comments or placeholder code\n\nüß™ **VERIFICATION:**\n```bash\nflutter analyze lib/core/constants/ lib/core/config/ lib/core/utils/\ndart format lib/core/constants/ lib/core/config/ lib/core/utils/\n```\n- Verify: All files compile without errors\n- Verify: No lint warnings",
        "epicId": "epic-flutter-foundation",
        "priority": 2,
        "estimatedComplexity": "moderate",
        "dependencies": [
          "epic-flutter-foundation-story-1"
        ],
        "status": "pending",
        "filesToRead": [
          "pubspec.yaml",
          "lib/main.dart"
        ],
        "filesToModify": [],
        "filesToCreate": [
          "lib/core/constants/app_constants.dart",
          "lib/core/constants/api_endpoints.dart",
          "lib/core/config/app_config.dart",
          "lib/core/config/environment.dart",
          "lib/core/utils/logger.dart",
          "lib/core/utils/validators.dart"
        ],
        "acceptanceCriteria": [
          "Given the constants files, When imported in other files, Then AppConstants and ApiEndpoints provide all necessary values",
          "Given EnvironmentConfig, When switching environments, Then baseUrl and logging settings change correctly",
          "Given AppLogger, When logging messages, Then output respects environment settings",
          "Given Validators, When validating email/password/phone, Then proper error messages are returned for invalid input"
        ]
      },
      {
        "id": "epic-flutter-foundation-story-3",
        "title": "Implement DioClient singleton with auth interceptor and error handling in lib/core/network/",
        "description": "Create Dio HTTP client with interceptors for authentication, logging, and error handling.\n\nüîí **SCOPE BOUNDARY:**\n- You can ONLY create the 3 network files listed below\n- DO NOT modify pubspec.yaml, main.dart, or any other files\n- DO NOT create storage or error files (other stories)\n\nüìÅ **FILES:**\n- Read: pubspec.yaml, lib/core/constants/app_constants.dart, lib/core/constants/api_endpoints.dart, lib/core/config/app_config.dart\n- Modify: NONE\n- Create:\n  - lib/core/network/dio_client.dart\n  - lib/core/network/api_interceptor.dart\n  - lib/core/network/network_info.dart\n\nüîß **IMPLEMENTATION DETAILS:**\n\n**network_info.dart:**\n```dart\nimport 'package:connectivity_plus/connectivity_plus.dart';\n\nabstract class NetworkInfo {\n  Future<bool> get isConnected;\n  Stream<bool> get onConnectivityChanged;\n}\n\nclass NetworkInfoImpl implements NetworkInfo {\n  final Connectivity _connectivity;\n  \n  NetworkInfoImpl({Connectivity? connectivity})\n      : _connectivity = connectivity ?? Connectivity();\n  \n  @override\n  Future<bool> get isConnected async {\n    final result = await _connectivity.checkConnectivity();\n    return !result.contains(ConnectivityResult.none);\n  }\n  \n  @override\n  Stream<bool> get onConnectivityChanged {\n    return _connectivity.onConnectivityChanged.map(\n      (results) => !results.contains(ConnectivityResult.none),\n    );\n  }\n}\n```\n\n**api_interceptor.dart:**\n```dart\nimport 'package:dio/dio.dart';\nimport '../utils/logger.dart';\nimport '../constants/app_constants.dart';\n\nclass AuthInterceptor extends Interceptor {\n  String? _accessToken;\n  String? _refreshToken;\n  \n  void setTokens({String? accessToken, String? refreshToken}) {\n    _accessToken = accessToken;\n    _refreshToken = refreshToken;\n  }\n  \n  void clearTokens() {\n    _accessToken = null;\n    _refreshToken = null;\n  }\n  \n  @override\n  void onRequest(RequestOptions options, RequestInterceptorHandler handler) {\n    if (_accessToken != null) {\n      options.headers['Authorization'] = 'Bearer $_accessToken';\n    }\n    options.headers['Content-Type'] = 'application/json';\n    options.headers['Accept'] = 'application/json';\n    \n    AppLogger.debug('REQUEST[${options.method}] => PATH: ${options.path}');\n    handler.next(options);\n  }\n  \n  @override\n  void onResponse(Response response, ResponseInterceptorHandler handler) {\n    AppLogger.debug(\n      'RESPONSE[${response.statusCode}] => PATH: ${response.requestOptions.path}',\n    );\n    handler.next(response);\n  }\n  \n  @override\n  void onError(DioException err, ErrorInterceptorHandler handler) {\n    AppLogger.error(\n      'ERROR[${err.response?.statusCode}] => PATH: ${err.requestOptions.path}',\n      err,\n    );\n    handler.next(err);\n  }\n}\n\nclass LoggingInterceptor extends Interceptor {\n  @override\n  void onRequest(RequestOptions options, RequestInterceptorHandler handler) {\n    AppLogger.info('‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');\n    AppLogger.info('‚îÇ ${options.method} ${options.uri}');\n    if (options.data != null) {\n      AppLogger.debug('‚îÇ Body: ${options.data}');\n    }\n    AppLogger.info('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');\n    handler.next(options);\n  }\n  \n  @override\n  void onResponse(Response response, ResponseInterceptorHandler handler) {\n    AppLogger.info('‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');\n    AppLogger.info('‚îÇ ${response.statusCode} ${response.requestOptions.uri}');\n    AppLogger.info('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');\n    handler.next(response);\n  }\n}\n\nclass RetryInterceptor extends Interceptor {\n  final Dio dio;\n  final int maxRetries;\n  \n  RetryInterceptor({required this.dio, this.maxRetries = AppConstants.maxRetries});\n  \n  @override\n  Future<void> onError(DioException err, ErrorInterceptorHandler handler) async {\n    if (_shouldRetry(err) && err.requestOptions.extra['retryCount'] == null) {\n      int retryCount = 0;\n      while (retryCount < maxRetries) {\n        retryCount++;\n        AppLogger.warning('Retrying request (attempt $retryCount/$maxRetries)');\n        try {\n          err.requestOptions.extra['retryCount'] = retryCount;\n          final response = await dio.fetch(err.requestOptions);\n          return handler.resolve(response);\n        } catch (e) {\n          if (retryCount >= maxRetries) {\n            return handler.next(err);\n          }\n          await Future.delayed(Duration(seconds: retryCount));\n        }\n      }\n    }\n    handler.next(err);\n  }\n  \n  bool _shouldRetry(DioException err) {\n    return err.type == DioExceptionType.connectionTimeout ||\n           err.type == DioExceptionType.receiveTimeout ||\n           err.type == DioExceptionType.connectionError;\n  }\n}\n```\n\n**dio_client.dart:**\n```dart\nimport 'package:dio/dio.dart';\nimport '../config/app_config.dart';\nimport '../constants/app_constants.dart';\nimport 'api_interceptor.dart';\nimport 'network_info.dart';\n\nclass DioClient {\n  static DioClient? _instance;\n  late final Dio _dio;\n  late final AuthInterceptor _authInterceptor;\n  late final NetworkInfo _networkInfo;\n  \n  DioClient._internal() {\n    _authInterceptor = AuthInterceptor();\n    _networkInfo = NetworkInfoImpl();\n    \n    _dio = Dio(\n      BaseOptions(\n        baseUrl: AppConfig.baseUrl,\n        connectTimeout: Duration(milliseconds: AppConstants.connectionTimeout),\n        receiveTimeout: Duration(milliseconds: AppConstants.receiveTimeout),\n        headers: {\n          'Content-Type': 'application/json',\n          'Accept': 'application/json',\n        },\n      ),\n    );\n    \n    _dio.interceptors.addAll([\n      _authInterceptor,\n      if (AppConfig.enableLogging) LoggingInterceptor(),\n      RetryInterceptor(dio: _dio),\n    ]);\n  }\n  \n  factory DioClient() {\n    _instance ??= DioClient._internal();\n    return _instance!;\n  }\n  \n  static void reset() {\n    _instance = null;\n  }\n  \n  Dio get dio => _dio;\n  NetworkInfo get networkInfo => _networkInfo;\n  \n  void setTokens({String? accessToken, String? refreshToken}) {\n    _authInterceptor.setTokens(\n      accessToken: accessToken,\n      refreshToken: refreshToken,\n    );\n  }\n  \n  void clearTokens() {\n    _authInterceptor.clearTokens();\n  }\n  \n  Future<Response<T>> get<T>(\n    String path, {\n    Map<String, dynamic>? queryParameters,\n    Options? options,\n    CancelToken? cancelToken,\n  }) async {\n    return _dio.get<T>(\n      path,\n      queryParameters: queryParameters,\n      options: options,\n      cancelToken: cancelToken,\n    );\n  }\n  \n  Future<Response<T>> post<T>(\n    String path, {\n    dynamic data,\n    Map<String, dynamic>? queryParameters,\n    Options? options,\n    CancelToken? cancelToken,\n  }) async {\n    return _dio.post<T>(\n      path,\n      data: data,\n      queryParameters: queryParameters,\n      options: options,\n      cancelToken: cancelToken,\n    );\n  }\n  \n  Future<Response<T>> put<T>(\n    String path, {\n    dynamic data,\n    Map<String, dynamic>? queryParameters,\n    Options? options,\n    CancelToken? cancelToken,\n  }) async {\n    return _dio.put<T>(\n      path,\n      data: data,\n      queryParameters: queryParameters,\n      options: options,\n      cancelToken: cancelToken,\n    );\n  }\n  \n  Future<Response<T>> delete<T>(\n    String path, {\n    dynamic data,\n    Map<String, dynamic>? queryParameters,\n    Options? options,\n    CancelToken? cancelToken,\n  }) async {\n    return _dio.delete<T>(\n      path,\n      data: data,\n      queryParameters: queryParameters,\n      options: options,\n      cancelToken: cancelToken,\n    );\n  }\n}\n```\n\n‚ö†Ô∏è **ANTI-PATTERNS TO AVOID:**\n- DO NOT create multiple Dio instances (use singleton pattern)\n- DO NOT hardcode timeouts (use AppConstants)\n- DO NOT skip logging interceptor configuration\n- DO NOT import from storage/ or errors/ directories\n\nüß™ **VERIFICATION:**\n```bash\nflutter analyze lib/core/network/\ndart format lib/core/network/\n```\n- Verify: DioClient singleton works correctly\n- Verify: AuthInterceptor adds Authorization header\n- Verify: All files compile without errors",
        "epicId": "epic-flutter-foundation",
        "priority": 2,
        "estimatedComplexity": "moderate",
        "dependencies": [
          "epic-flutter-foundation-story-1"
        ],
        "status": "pending",
        "filesToRead": [
          "pubspec.yaml",
          "lib/core/constants/app_constants.dart",
          "lib/core/constants/api_endpoints.dart",
          "lib/core/config/app_config.dart"
        ],
        "filesToModify": [],
        "filesToCreate": [
          "lib/core/network/dio_client.dart",
          "lib/core/network/api_interceptor.dart",
          "lib/core/network/network_info.dart"
        ],
        "acceptanceCriteria": [
          "Given DioClient, When instantiated multiple times, Then same instance is returned (singleton)",
          "Given AuthInterceptor with token, When request is made, Then Authorization header is added",
          "Given NetworkInfo, When checking connectivity, Then correct boolean is returned",
          "Given RetryInterceptor, When connection timeout occurs, Then request is retried up to maxRetries times"
        ]
      },
      {
        "id": "epic-flutter-foundation-story-4",
        "title": "Implement SecureStorage wrapper using flutter_secure_storage in lib/core/storage/",
        "description": "Create secure storage wrapper for JWT token persistence and local storage utilities.\n\nüîí **SCOPE BOUNDARY:**\n- You can ONLY create the 2 storage files listed below\n- DO NOT modify pubspec.yaml, main.dart, or any other files\n- DO NOT create network or error files (other stories)\n\nüìÅ **FILES:**\n- Read: pubspec.yaml, lib/core/constants/app_constants.dart\n- Modify: NONE\n- Create:\n  - lib/core/storage/secure_storage.dart\n  - lib/core/storage/local_storage.dart\n\nüîß **IMPLEMENTATION DETAILS:**\n\n**secure_storage.dart:**\n```dart\nimport 'package:flutter_secure_storage/flutter_secure_storage.dart';\nimport '../constants/app_constants.dart';\nimport '../utils/logger.dart';\n\nabstract class SecureStorage {\n  Future<void> write({required String key, required String value});\n  Future<String?> read({required String key});\n  Future<void> delete({required String key});\n  Future<void> deleteAll();\n  Future<bool> containsKey({required String key});\n}\n\nclass SecureStorageImpl implements SecureStorage {\n  static SecureStorageImpl? _instance;\n  late final FlutterSecureStorage _storage;\n  \n  SecureStorageImpl._internal() {\n    _storage = const FlutterSecureStorage(\n      aOptions: AndroidOptions(\n        encryptedSharedPreferences: true,\n      ),\n      iOptions: IOSOptions(\n        accessibility: KeychainAccessibility.first_unlock_this_device,\n      ),\n    );\n  }\n  \n  factory SecureStorageImpl() {\n    _instance ??= SecureStorageImpl._internal();\n    return _instance!;\n  }\n  \n  static void reset() {\n    _instance = null;\n  }\n  \n  @override\n  Future<void> write({required String key, required String value}) async {\n    try {\n      await _storage.write(key: key, value: value);\n      AppLogger.debug('SecureStorage: Written key \"$key\"');\n    } catch (e, stackTrace) {\n      AppLogger.error('SecureStorage: Failed to write key \"$key\"', e, stackTrace);\n      rethrow;\n    }\n  }\n  \n  @override\n  Future<String?> read({required String key}) async {\n    try {\n      final value = await _storage.read(key: key);\n      AppLogger.debug('SecureStorage: Read key \"$key\" (found: ${value != null})');\n      return value;\n    } catch (e, stackTrace) {\n      AppLogger.error('SecureStorage: Failed to read key \"$key\"', e, stackTrace);\n      rethrow;\n    }\n  }\n  \n  @override\n  Future<void> delete({required String key}) async {\n    try {\n      await _storage.delete(key: key);\n      AppLogger.debug('SecureStorage: Deleted key \"$key\"');\n    } catch (e, stackTrace) {\n      AppLogger.error('SecureStorage: Failed to delete key \"$key\"', e, stackTrace);\n      rethrow;\n    }\n  }\n  \n  @override\n  Future<void> deleteAll() async {\n    try {\n      await _storage.deleteAll();\n      AppLogger.debug('SecureStorage: Deleted all keys');\n    } catch (e, stackTrace) {\n      AppLogger.error('SecureStorage: Failed to delete all keys', e, stackTrace);\n      rethrow;\n    }\n  }\n  \n  @override\n  Future<bool> containsKey({required String key}) async {\n    try {\n      return await _storage.containsKey(key: key);\n    } catch (e, stackTrace) {\n      AppLogger.error('SecureStorage: Failed to check key \"$key\"', e, stackTrace);\n      rethrow;\n    }\n  }\n}\n\nclass TokenStorage {\n  final SecureStorage _secureStorage;\n  \n  TokenStorage({SecureStorage? secureStorage})\n      : _secureStorage = secureStorage ?? SecureStorageImpl();\n  \n  Future<void> saveAccessToken(String token) async {\n    await _secureStorage.write(\n      key: AppConstants.accessTokenKey,\n      value: token,\n    );\n  }\n  \n  Future<String?> getAccessToken() async {\n    return await _secureStorage.read(key: AppConstants.accessTokenKey);\n  }\n  \n  Future<void> saveRefreshToken(String token) async {\n    await _secureStorage.write(\n      key: AppConstants.refreshTokenKey,\n      value: token,\n    );\n  }\n  \n  Future<String?> getRefreshToken() async {\n    return await _secureStorage.read(key: AppConstants.refreshTokenKey);\n  }\n  \n  Future<void> saveTokens({required String accessToken, required String refreshToken}) async {\n    await Future.wait([\n      saveAccessToken(accessToken),\n      saveRefreshToken(refreshToken),\n    ]);\n  }\n  \n  Future<void> clearTokens() async {\n    await Future.wait([\n      _secureStorage.delete(key: AppConstants.accessTokenKey),\n      _secureStorage.delete(key: AppConstants.refreshTokenKey),\n    ]);\n  }\n  \n  Future<bool> hasValidToken() async {\n    final token = await getAccessToken();\n    return token != null && token.isNotEmpty;\n  }\n}\n```\n\n**local_storage.dart:**\n```dart\nimport 'dart:convert';\nimport 'package:shared_preferences/shared_preferences.dart';\nimport '../utils/logger.dart';\n\nabstract class LocalStorage {\n  Future<void> setString(String key, String value);\n  Future<String?> getString(String key);\n  Future<void> setBool(String key, bool value);\n  Future<bool?> getBool(String key);\n  Future<void> setInt(String key, int value);\n  Future<int?> getInt(String key);\n  Future<void> setDouble(String key, double value);\n  Future<double?> getDouble(String key);\n  Future<void> setJson(String key, Map<String, dynamic> value);\n  Future<Map<String, dynamic>?> getJson(String key);\n  Future<void> remove(String key);\n  Future<void> clear();\n}\n\nclass LocalStorageImpl implements LocalStorage {\n  SharedPreferences? _prefs;\n  \n  Future<SharedPreferences> get _preferences async {\n    _prefs ??= await SharedPreferences.getInstance();\n    return _prefs!;\n  }\n  \n  @override\n  Future<void> setString(String key, String value) async {\n    try {\n      final prefs = await _preferences;\n      await prefs.setString(key, value);\n      AppLogger.debug('LocalStorage: Set string \"$key\"');\n    } catch (e, stackTrace) {\n      AppLogger.error('LocalStorage: Failed to set string \"$key\"', e, stackTrace);\n      rethrow;\n    }\n  }\n  \n  @override\n  Future<String?> getString(String key) async {\n    try {\n      final prefs = await _preferences;\n      return prefs.getString(key);\n    } catch (e, stackTrace) {\n      AppLogger.error('LocalStorage: Failed to get string \"$key\"', e, stackTrace);\n      rethrow;\n    }\n  }\n  \n  @override\n  Future<void> setBool(String key, bool value) async {\n    try {\n      final prefs = await _preferences;\n      await prefs.setBool(key, value);\n      AppLogger.debug('LocalStorage: Set bool \"$key\"');\n    } catch (e, stackTrace) {\n      AppLogger.error('LocalStorage: Failed to set bool \"$key\"', e, stackTrace);\n      rethrow;\n    }\n  }\n  \n  @override\n  Future<bool?> getBool(String key) async {\n    try {\n      final prefs = await _preferences;\n      return prefs.getBool(key);\n    } catch (e, stackTrace) {\n      AppLogger.error('LocalStorage: Failed to get bool \"$key\"', e, stackTrace);\n      rethrow;\n    }\n  }\n  \n  @override\n  Future<void> setInt(String key, int value) async {\n    try {\n      final prefs = await _preferences;\n      await prefs.setInt(key, value);\n      AppLogger.debug('LocalStorage: Set int \"$key\"');\n    } catch (e, stackTrace) {\n      AppLogger.error('LocalStorage: Failed to set int \"$key\"', e, stackTrace);\n      rethrow;\n    }\n  }\n  \n  @override\n  Future<int?> getInt(String key) async {\n    try {\n      final prefs = await _preferences;\n      return prefs.getInt(key);\n    } catch (e, stackTrace) {\n      AppLogger.error('LocalStorage: Failed to get int \"$key\"', e, stackTrace);\n      rethrow;\n    }\n  }\n  \n  @override\n  Future<void> setDouble(String key, double value) async {\n    try {\n      final prefs = await _preferences;\n      await prefs.setDouble(key, value);\n      AppLogger.debug('LocalStorage: Set double \"$key\"');\n    } catch (e, stackTrace) {\n      AppLogger.error('LocalStorage: Failed to set double \"$key\"', e, stackTrace);\n      rethrow;\n    }\n  }\n  \n  @override\n  Future<double?> getDouble(String key) async {\n    try {\n      final prefs = await _preferences;\n      return prefs.getDouble(key);\n    } catch (e, stackTrace) {\n      AppLogger.error('LocalStorage: Failed to get double \"$key\"', e, stackTrace);\n      rethrow;\n    }\n  }\n  \n  @override\n  Future<void> setJson(String key, Map<String, dynamic> value) async {\n    try {\n      final prefs = await _preferences;\n      final jsonString = jsonEncode(value);\n      await prefs.setString(key, jsonString);\n      AppLogger.debug('LocalStorage: Set JSON \"$key\"');\n    } catch (e, stackTrace) {\n      AppLogger.error('LocalStorage: Failed to set JSON \"$key\"', e, stackTrace);\n      rethrow;\n    }\n  }\n  \n  @override\n  Future<Map<String, dynamic>?> getJson(String key) async {\n    try {\n      final prefs = await _preferences;\n      final jsonString = prefs.getString(key);\n      if (jsonString == null) return null;\n      return jsonDecode(jsonString) as Map<String, dynamic>;\n    } catch (e, stackTrace) {\n      AppLogger.error('LocalStorage: Failed to get JSON \"$key\"', e, stackTrace);\n      rethrow;\n    }\n  }\n  \n  @override\n  Future<void> remove(String key) async {\n    try {\n      final prefs = await _preferences;\n      await prefs.remove(key);\n      AppLogger.debug('LocalStorage: Removed \"$key\"');\n    } catch (e, stackTrace) {\n      AppLogger.error('LocalStorage: Failed to remove \"$key\"', e, stackTrace);\n      rethrow;\n    }\n  }\n  \n  @override\n  Future<void> clear() async {\n    try {\n      final prefs = await _preferences;\n      await prefs.clear();\n      AppLogger.debug('LocalStorage: Cleared all');\n    } catch (e, stackTrace) {\n      AppLogger.error('LocalStorage: Failed to clear', e, stackTrace);\n      rethrow;\n    }\n  }\n}\n```\n\n‚ö†Ô∏è **ANTI-PATTERNS TO AVOID:**\n- DO NOT store tokens in LocalStorage (use SecureStorage)\n- DO NOT skip platform-specific options for FlutterSecureStorage\n- DO NOT log token values (only log key names)\n- DO NOT import from network/ or errors/ directories\n\nüß™ **VERIFICATION:**\n```bash\nflutter analyze lib/core/storage/\ndart format lib/core/storage/\n```\n- Verify: SecureStorage uses encrypted preferences on Android\n- Verify: TokenStorage provides convenient token management\n- Verify: LocalStorage handles JSON serialization correctly",
        "epicId": "epic-flutter-foundation",
        "priority": 2,
        "estimatedComplexity": "moderate",
        "dependencies": [
          "epic-flutter-foundation-story-1"
        ],
        "status": "pending",
        "filesToRead": [
          "pubspec.yaml",
          "lib/core/constants/app_constants.dart"
        ],
        "filesToModify": [],
        "filesToCreate": [
          "lib/core/storage/secure_storage.dart",
          "lib/core/storage/local_storage.dart"
        ],
        "acceptanceCriteria": [
          "Given SecureStorageImpl, When storing token, Then it uses encrypted storage with platform-specific options",
          "Given TokenStorage, When saving access and refresh tokens, Then both are stored securely",
          "Given LocalStorage, When storing JSON data, Then it correctly serializes and deserializes",
          "Given TokenStorage.hasValidToken(), When token exists, Then returns true"
        ]
      },
      {
        "id": "epic-flutter-foundation-story-5",
        "title": "Create AppException classes, ErrorHandler, lib/app.dart and update lib/main.dart",
        "description": "Implement error handling utilities and create the App widget with proper initialization.\n\nüîí **SCOPE BOUNDARY:**\n- You can ONLY create/modify the 4 files listed below\n- DO NOT modify pubspec.yaml or any network/storage files\n\nüìÅ **FILES:**\n- Read: pubspec.yaml, lib/core/config/app_config.dart, lib/core/config/environment.dart, lib/core/utils/logger.dart, lib/core/network/dio_client.dart, lib/core/storage/secure_storage.dart\n- Modify: lib/main.dart\n- Create:\n  - lib/core/errors/app_exceptions.dart\n  - lib/core/errors/error_handler.dart\n  - lib/app.dart\n\nüîß **IMPLEMENTATION DETAILS:**\n\n**app_exceptions.dart:**\n```dart\nimport 'package:equatable/equatable.dart';\n\nabstract class AppException extends Equatable implements Exception {\n  final String message;\n  final String? code;\n  final dynamic originalError;\n  final StackTrace? stackTrace;\n  \n  const AppException({\n    required this.message,\n    this.code,\n    this.originalError,\n    this.stackTrace,\n  });\n  \n  @override\n  List<Object?> get props => [message, code];\n  \n  @override\n  String toString() => 'AppException: $message (code: $code)';\n}\n\nclass NetworkException extends AppException {\n  final int? statusCode;\n  \n  const NetworkException({\n    required super.message,\n    super.code,\n    super.originalError,\n    super.stackTrace,\n    this.statusCode,\n  });\n  \n  @override\n  List<Object?> get props => [...super.props, statusCode];\n  \n  factory NetworkException.noConnection() => const NetworkException(\n    message: 'No internet connection. Please check your network settings.',\n    code: 'NO_CONNECTION',\n  );\n  \n  factory NetworkException.timeout() => const NetworkException(\n    message: 'Connection timed out. Please try again.',\n    code: 'TIMEOUT',\n  );\n  \n  factory NetworkException.serverError({int? statusCode, String? message}) => NetworkException(\n    message: message ?? 'Server error occurred. Please try again later.',\n    code: 'SERVER_ERROR',\n    statusCode: statusCode,\n  );\n  \n  factory NetworkException.unauthorized() => const NetworkException(\n    message: 'Session expired. Please login again.',\n    code: 'UNAUTHORIZED',\n    statusCode: 401,\n  );\n  \n  factory NetworkException.forbidden() => const NetworkException(\n    message: 'You do not have permission to perform this action.',\n    code: 'FORBIDDEN',\n    statusCode: 403,\n  );\n  \n  factory NetworkException.notFound() => const NetworkException(\n    message: 'The requested resource was not found.',\n    code: 'NOT_FOUND',\n    statusCode: 404,\n  );\n}\n\nclass ValidationException extends AppException {\n  final Map<String, String>? fieldErrors;\n  \n  const ValidationException({\n    required super.message,\n    super.code = 'VALIDATION_ERROR',\n    super.originalError,\n    super.stackTrace,\n    this.fieldErrors,\n  });\n  \n  @override\n  List<Object?> get props => [...super.props, fieldErrors];\n}\n\nclass StorageException extends AppException {\n  const StorageException({\n    required super.message,\n    super.code = 'STORAGE_ERROR',\n    super.originalError,\n    super.stackTrace,\n  });\n  \n  factory StorageException.readError(String key) => StorageException(\n    message: 'Failed to read data for key: $key',\n    code: 'READ_ERROR',\n  );\n  \n  factory StorageException.writeError(String key) => StorageException(\n    message: 'Failed to write data for key: $key',\n    code: 'WRITE_ERROR',\n  );\n}\n\nclass AuthException extends AppException {\n  const AuthException({\n    required super.message,\n    super.code = 'AUTH_ERROR',\n    super.originalError,\n    super.stackTrace,\n  });\n  \n  factory AuthException.invalidCredentials() => const AuthException(\n    message: 'Invalid email or password.',\n    code: 'INVALID_CREDENTIALS',\n  );\n  \n  factory AuthException.sessionExpired() => const AuthException(\n    message: 'Your session has expired. Please login again.',\n    code: 'SESSION_EXPIRED',\n  );\n  \n  factory AuthException.accountDisabled() => const AuthException(\n    message: 'Your account has been disabled.',\n    code: 'ACCOUNT_DISABLED',\n  );\n}\n\nclass CacheException extends AppException {\n  const CacheException({\n    required super.message,\n    super.code = 'CACHE_ERROR',\n    super.originalError,\n    super.stackTrace,\n  });\n}\n\nclass UnknownException extends AppException {\n  const UnknownException({\n    super.message = 'An unexpected error occurred. Please try again.',\n    super.code = 'UNKNOWN_ERROR',\n    super.originalError,\n    super.stackTrace,\n  });\n}\n```\n\n**error_handler.dart:**\n```dart\nimport 'package:dio/dio.dart';\nimport 'package:flutter/material.dart';\nimport '../utils/logger.dart';\nimport 'app_exceptions.dart';\n\nclass ErrorHandler {\n  static AppException handleException(dynamic error, [StackTrace? stackTrace]) {\n    AppLogger.error('ErrorHandler: Handling error', error, stackTrace);\n    \n    if (error is AppException) {\n      return error;\n    }\n    \n    if (error is DioException) {\n      return _handleDioException(error, stackTrace);\n    }\n    \n    if (error is FormatException) {\n      return ValidationException(\n        message: 'Invalid data format: ${error.message}',\n        originalError: error,\n        stackTrace: stackTrace,\n      );\n    }\n    \n    if (error is TypeError) {\n      return UnknownException(\n        message: 'Data type error occurred.',\n        originalError: error,\n        stackTrace: stackTrace,\n      );\n    }\n    \n    return UnknownException(\n      message: error?.toString() ?? 'An unexpected error occurred.',\n      originalError: error,\n      stackTrace: stackTrace,\n    );\n  }\n  \n  static NetworkException _handleDioException(DioException error, [StackTrace? stackTrace]) {\n    switch (error.type) {\n      case DioExceptionType.connectionTimeout:\n      case DioExceptionType.sendTimeout:\n      case DioExceptionType.receiveTimeout:\n        return NetworkException.timeout();\n      \n      case DioExceptionType.connectionError:\n        return NetworkException.noConnection();\n      \n      case DioExceptionType.badResponse:\n        return _handleStatusCode(\n          error.response?.statusCode,\n          error.response?.data,\n          error,\n          stackTrace,\n        );\n      \n      case DioExceptionType.cancel:\n        return const NetworkException(\n          message: 'Request was cancelled.',\n          code: 'REQUEST_CANCELLED',\n        );\n      \n      case DioExceptionType.badCertificate:\n        return const NetworkException(\n          message: 'Certificate verification failed.',\n          code: 'CERTIFICATE_ERROR',\n        );\n      \n      case DioExceptionType.unknown:\n      default:\n        if (error.error != null && error.error.toString().contains('SocketException')) {\n          return NetworkException.noConnection();\n        }\n        return NetworkException(\n          message: 'Network error occurred.',\n          code: 'NETWORK_ERROR',\n          originalError: error,\n          stackTrace: stackTrace,\n        );\n    }\n  }\n  \n  static NetworkException _handleStatusCode(\n    int? statusCode,\n    dynamic responseData,\n    DioException error,\n    StackTrace? stackTrace,\n  ) {\n    final String? serverMessage = _extractServerMessage(responseData);\n    \n    switch (statusCode) {\n      case 400:\n        return NetworkException(\n          message: serverMessage ?? 'Bad request. Please check your input.',\n          code: 'BAD_REQUEST',\n          statusCode: 400,\n          originalError: error,\n          stackTrace: stackTrace,\n        );\n      case 401:\n        return NetworkException.unauthorized();\n      case 403:\n        return NetworkException.forbidden();\n      case 404:\n        return NetworkException.notFound();\n      case 422:\n        return NetworkException(\n          message: serverMessage ?? 'Validation error.',\n          code: 'VALIDATION_ERROR',\n          statusCode: 422,\n          originalError: error,\n          stackTrace: stackTrace,\n        );\n      case 429:\n        return const NetworkException(\n          message: 'Too many requests. Please wait and try again.',\n          code: 'RATE_LIMITED',\n          statusCode: 429,\n        );\n      case 500:\n      case 502:\n      case 503:\n      case 504:\n        return NetworkException.serverError(\n          statusCode: statusCode,\n          message: serverMessage,\n        );\n      default:\n        return NetworkException(\n          message: serverMessage ?? 'An error occurred.',\n          code: 'HTTP_ERROR',\n          statusCode: statusCode,\n          originalError: error,\n          stackTrace: stackTrace,\n        );\n    }\n  }\n  \n  static String? _extractServerMessage(dynamic data) {\n    if (data == null) return null;\n    if (data is String) return data;\n    if (data is Map) {\n      return data['message'] as String? ??\n             data['error'] as String? ??\n             data['errors']?.toString();\n    }\n    return null;\n  }\n  \n  static void showErrorSnackBar(BuildContext context, AppException exception) {\n    ScaffoldMessenger.of(context).showSnackBar(\n      SnackBar(\n        content: Text(exception.message),\n        backgroundColor: Colors.red.shade700,\n        behavior: SnackBarBehavior.floating,\n        action: SnackBarAction(\n          label: 'Dismiss',\n          textColor: Colors.white,\n          onPressed: () {\n            ScaffoldMessenger.of(context).hideCurrentSnackBar();\n          },\n        ),\n      ),\n    );\n  }\n}\n```\n\n**lib/app.dart:**\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\nimport 'core/config/app_config.dart';\nimport 'core/config/environment.dart';\nimport 'core/utils/logger.dart';\nimport 'core/network/dio_client.dart';\nimport 'core/storage/secure_storage.dart';\n\nclass App extends StatelessWidget {\n  const App({super.key});\n  \n  @override\n  Widget build(BuildContext context) {\n    return MultiProvider(\n      providers: [\n        Provider<DioClient>.value(value: DioClient()),\n        Provider<TokenStorage>.value(value: TokenStorage()),\n        Provider<LocalStorageImpl>.value(value: LocalStorageImpl()),\n      ],\n      child: MaterialApp(\n        title: 'App Pasos',\n        debugShowCheckedModeBanner: !AppConfig.isProduction,\n        theme: ThemeData(\n          colorScheme: ColorScheme.fromSeed(\n            seedColor: Colors.deepPurple,\n            brightness: Brightness.light,\n          ),\n          useMaterial3: true,\n          appBarTheme: const AppBarTheme(\n            centerTitle: true,\n            elevation: 0,\n          ),\n          elevatedButtonTheme: ElevatedButtonThemeData(\n            style: ElevatedButton.styleFrom(\n              padding: const EdgeInsets.symmetric(horizontal: 32, vertical: 16),\n              shape: RoundedRectangleBorder(\n                borderRadius: BorderRadius.circular(12),\n              ),\n            ),\n          ),\n          inputDecorationTheme: InputDecorationTheme(\n            filled: true,\n            border: OutlineInputBorder(\n              borderRadius: BorderRadius.circular(12),\n            ),\n            contentPadding: const EdgeInsets.symmetric(\n              horizontal: 16,\n              vertical: 16,\n            ),\n          ),\n        ),\n        darkTheme: ThemeData(\n          colorScheme: ColorScheme.fromSeed(\n            seedColor: Colors.deepPurple,\n            brightness: Brightness.dark,\n          ),\n          useMaterial3: true,\n        ),\n        themeMode: ThemeMode.system,\n        home: const _HomeScreen(),\n      ),\n    );\n  }\n}\n\nclass _HomeScreen extends StatelessWidget {\n  const _HomeScreen();\n  \n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('App Pasos'),\n        backgroundColor: Theme.of(context).colorScheme.inversePrimary,\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Icon(\n              Icons.check_circle_outline,\n              size: 80,\n              color: Theme.of(context).colorScheme.primary,\n            ),\n            const SizedBox(height: 24),\n            Text(\n              'Foundation Setup Complete',\n              style: Theme.of(context).textTheme.headlineSmall,\n            ),\n            const SizedBox(height: 8),\n            Text(\n              'Environment: ${AppConfig.environment.name}',\n              style: Theme.of(context).textTheme.bodyLarge?.copyWith(\n                color: Theme.of(context).colorScheme.secondary,\n              ),\n            ),\n            const SizedBox(height: 32),\n            ElevatedButton.icon(\n              onPressed: () {\n                AppLogger.info('Test button pressed');\n                ScaffoldMessenger.of(context).showSnackBar(\n                  const SnackBar(\n                    content: Text('Logger is working!'),\n                    behavior: SnackBarBehavior.floating,\n                  ),\n                );\n              },\n              icon: const Icon(Icons.bug_report),\n              label: const Text('Test Logger'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n```\n\n**lib/main.dart** (REPLACE ENTIRE FILE):\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\nimport 'core/config/app_config.dart';\nimport 'core/config/environment.dart';\nimport 'core/utils/logger.dart';\nimport 'app.dart';\n\nvoid main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  \n  // Initialize configuration (use development for now)\n  AppConfig.initialize(EnvironmentConfig.development);\n  \n  // Initialize logger\n  AppLogger.initialize();\n  \n  // Set preferred orientations\n  await SystemChrome.setPreferredOrientations([\n    DeviceOrientation.portraitUp,\n    DeviceOrientation.portraitDown,\n  ]);\n  \n  // Set system UI overlay style\n  SystemChrome.setSystemUIOverlayStyle(\n    const SystemUiOverlayStyle(\n      statusBarColor: Colors.transparent,\n      statusBarIconBrightness: Brightness.dark,\n      systemNavigationBarColor: Colors.white,\n      systemNavigationBarIconBrightness: Brightness.dark,\n    ),\n  );\n  \n  AppLogger.info('App starting in ${AppConfig.environment.name} mode');\n  \n  runApp(const App());\n}\n```\n\n‚ö†Ô∏è **ANTI-PATTERNS TO AVOID:**\n- DO NOT use generic Exception (use AppException hierarchy)\n- DO NOT swallow errors without logging\n- DO NOT show raw error messages to users\n- DO NOT leave placeholder \"Coming Soon\" widgets\n\nüß™ **VERIFICATION:**\n```bash\nflutter analyze\ndart format lib/\nflutter run\n```\n- Verify: App launches without errors\n- Verify: Logger outputs messages in debug mode\n- Verify: ErrorHandler converts DioException to NetworkException\n- Verify: All exception types extend AppException",
        "epicId": "epic-flutter-foundation",
        "priority": 3,
        "estimatedComplexity": "moderate",
        "dependencies": [
          "epic-flutter-foundation-story-2",
          "epic-flutter-foundation-story-3",
          "epic-flutter-foundation-story-4"
        ],
        "status": "pending",
        "filesToRead": [
          "pubspec.yaml",
          "lib/core/config/app_config.dart",
          "lib/core/config/environment.dart",
          "lib/core/utils/logger.dart",
          "lib/core/network/dio_client.dart",
          "lib/core/storage/secure_storage.dart"
        ],
        "filesToModify": [
          "lib/main.dart"
        ],
        "filesToCreate": [
          "lib/core/errors/app_exceptions.dart",
          "lib/core/errors/error_handler.dart",
          "lib/app.dart"
        ],
        "acceptanceCriteria": [
          "Given any error type, When passed to ErrorHandler.handleException(), Then appropriate AppException subclass is returned",
          "Given DioException with status 401, When handled, Then NetworkException.unauthorized() is returned",
          "Given the App widget, When running the app, Then proper theme and providers are configured",
          "Given main.dart, When app starts, Then AppConfig and AppLogger are initialized before runApp"
        ]
      }
    ]
  }
}