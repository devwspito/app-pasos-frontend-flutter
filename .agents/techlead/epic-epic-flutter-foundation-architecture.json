{
  "_metadata": {
    "agentType": "techlead",
    "taskId": "7ad1acb8410d7d7ed6394f98",
    "timestamp": "2026-01-24T13:15:07.958Z",
    "phase": "techlead",
    "epicId": "epic-flutter-foundation",
    "savedAt": "2026-01-24T13:15:07.959Z",
    "version": "1.0"
  },
  "data": {
    "epicId": "epic-flutter-foundation",
    "storiesCount": 5,
    "architecture": "## Flutter Foundation Architecture\n\n### Architecture Pattern: Feature-Based Clean Architecture\n\nThis foundation implements a scalable Flutter architecture following SOLID principles:\n\n**1. Dependency Inversion (DIP)**\n- All dependencies flow inward: UI ‚Üí Domain ‚Üí Data\n- Abstractions (interfaces) defined for NetworkInfo, ApiClient\n- get_it service locator for dependency injection\n\n**2. Single Responsibility (SRP)**\n- ApiClient: HTTP communication only\n- NetworkInfo: Connectivity checking only\n- Validators: Input validation only\n- Logger: Logging only\n\n**3. Open/Closed (OCP)**\n- Failure classes are sealed (extensible via new types)\n- Interceptors can be added without modifying ApiClient\n\n**Directory Structure:**\n```\nlib/\n‚îú‚îÄ‚îÄ app.dart                    # Root widget\n‚îú‚îÄ‚îÄ main.dart                   # Entry point\n‚îú‚îÄ‚îÄ core/\n‚îÇ   ‚îú‚îÄ‚îÄ constants/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ app_constants.dart  # App-wide constants\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ api_endpoints.dart  # API route constants\n‚îÇ   ‚îú‚îÄ‚îÄ di/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ injection_container.dart  # get_it setup\n‚îÇ   ‚îú‚îÄ‚îÄ errors/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ exceptions.dart     # Runtime exceptions\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ failures.dart       # Functional failures (Either)\n‚îÇ   ‚îú‚îÄ‚îÄ network/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api_client.dart     # Dio HTTP wrapper\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api_interceptor.dart # Logging/Auth interceptors\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ network_info.dart   # Connectivity checker\n‚îÇ   ‚îî‚îÄ‚îÄ utils/\n‚îÇ       ‚îú‚îÄ‚îÄ logger.dart         # Logging utility\n‚îÇ       ‚îî‚îÄ‚îÄ validators.dart     # Form validators\n‚îî‚îÄ‚îÄ env/\n    ‚îî‚îÄ‚îÄ env_config.dart         # Environment configuration\n```\n\n**Key Patterns:**\n- Either<Failure, Success> for error handling (dartz)\n- Sealed classes for exhaustive error handling\n- Singleton pattern for Logger\n- Factory pattern for DI registration\n- Interceptor pattern for cross-cutting concerns\n\n**Execution Order:**\n1. Story 1 (pubspec.yaml + analysis_options) - First, adds dependencies\n2. Stories 2, 3, 4 (parallel) - Constants, Errors, Utils\n3. Story 5 (Network + DI + App) - Last, integrates all components",
    "stories": [
      {
        "id": "epic-flutter-foundation-story-1",
        "title": "Add core dependencies to pubspec.yaml and enhance analysis_options.yaml",
        "description": "**Description:**\nUpdate pubspec.yaml with essential Flutter packages for the architecture foundation and enhance analysis_options.yaml with stricter linting rules for code quality.\n\nüîí **SCOPE BOUNDARY:**\n- You can ONLY modify files listed below\n- Creating ANY other file is a scope violation\n\nüìÅ **FILES:**\n- Read: [pubspec.yaml](lib/../pubspec.yaml), [analysis_options.yaml](lib/../analysis_options.yaml)\n- Modify: [pubspec.yaml](pubspec.yaml), [analysis_options.yaml](analysis_options.yaml)\n- Create: NONE\n\nüîß **PATTERNS TO USE:**\n- Follow existing pubspec.yaml structure (name, description, version, environment, dependencies)\n- Keep flutter_lints as base, add additional rules\n- Use caret syntax for version constraints (^x.x.x)\n\nüì¶ **DEPENDENCIES TO ADD:**\n```yaml\ndependencies:\n  get_it: ^7.6.7          # Dependency injection\n  dio: ^5.4.0             # HTTP client\n  connectivity_plus: ^5.0.2  # Network connectivity\n  flutter_dotenv: ^5.1.0  # Environment variables\n  equatable: ^2.0.5       # Value equality for classes\n  dartz: ^0.10.1          # Functional programming (Either type)\n  logger: ^2.0.2+1        # Logging utility\n\ndev_dependencies:\n  very_good_analysis: ^5.1.0  # Stricter linting\n  mocktail: ^1.0.3        # Mocking for tests\n```\n\n‚ö†Ô∏è **ANTI-PATTERNS TO AVOID:**\n- DO NOT use fixed versions without caret (1.0.0 instead of ^1.0.0)\n- DO NOT remove existing dependencies (cupertino_icons, flutter_lints)\n- DO NOT change SDK constraints\n\nüéØ **FUNCTIONAL REQUIREMENTS:**\n1. pubspec.yaml must have all dependencies listed above\n2. analysis_options.yaml must include stricter rules:\n   - prefer_const_constructors: true\n   - prefer_const_declarations: true\n   - prefer_final_locals: true\n   - avoid_print: true\n   - require_trailing_commas: true\n3. Run `flutter pub get` must succeed\n\nüß™ **VERIFICATION:**\n```bash\nflutter pub get\nflutter analyze\n```",
        "epicId": "epic-flutter-foundation",
        "priority": 1,
        "estimatedComplexity": "simple",
        "dependencies": [],
        "status": "pending",
        "filesToRead": [
          "pubspec.yaml",
          "analysis_options.yaml"
        ],
        "filesToModify": [
          "pubspec.yaml",
          "analysis_options.yaml"
        ],
        "filesToCreate": [],
        "acceptanceCriteria": [
          "Given pubspec.yaml is updated, When running flutter pub get, Then all dependencies install successfully",
          "Given analysis_options.yaml is updated, When running flutter analyze, Then no errors are reported",
          "Given get_it dependency is added, When importing get_it in a Dart file, Then it compiles without errors",
          "Given dio dependency is added, When importing dio in a Dart file, Then it compiles without errors"
        ]
      },
      {
        "id": "epic-flutter-foundation-story-2",
        "title": "Create lib/core/constants/app_constants.dart, lib/core/constants/api_endpoints.dart, lib/env/env_config.dart, and .env.example",
        "description": "**Description:**\nCreate core constants and environment configuration files to centralize app-wide settings, API endpoints, and environment-specific configurations.\n\nüîí **SCOPE BOUNDARY:**\n- You can ONLY create files listed below\n- Creating ANY other file is a scope violation\n\nüìÅ **FILES:**\n- Read: [pubspec.yaml](pubspec.yaml)\n- Modify: NONE\n- Create: [lib/core/constants/app_constants.dart](lib/core/constants/app_constants.dart), [lib/core/constants/api_endpoints.dart](lib/core/constants/api_endpoints.dart), [lib/env/env_config.dart](lib/env/env_config.dart), [.env.example](.env.example)\n\nüîß **PATTERNS TO USE:**\n- Use abstract final classes for constants (Dart 3 pattern)\n- Use static const for all constant values\n- Use flutter_dotenv for environment loading\n- Follow naming: SCREAMING_SNAKE_CASE for constants\n\nüì¶ **REQUIRED IMPLEMENTATION:**\n\n**app_constants.dart:**\n```dart\nabstract final class AppConstants {\n  static const String appName = 'App Pasos';\n  static const String appVersion = '1.0.0';\n  static const Duration defaultTimeout = Duration(seconds: 30);\n  static const Duration connectionTimeout = Duration(seconds: 15);\n  static const int maxRetries = 3;\n}\n```\n\n**api_endpoints.dart:**\n```dart\nabstract final class ApiEndpoints {\n  static const String auth = '/auth';\n  static const String login = '/auth/login';\n  static const String register = '/auth/register';\n  static const String users = '/users';\n  static const String profile = '/users/profile';\n}\n```\n\n**env_config.dart:**\n```dart\nimport 'package:flutter_dotenv/flutter_dotenv.dart';\n\nabstract final class EnvConfig {\n  static String get apiBaseUrl => dotenv.env['API_BASE_URL'] ?? 'http://localhost:3000/api';\n  static String get environment => dotenv.env['ENVIRONMENT'] ?? 'development';\n  static bool get isProduction => environment == 'production';\n  static bool get isDevelopment => environment == 'development';\n}\n```\n\n**.env.example:**\n```\nAPI_BASE_URL=http://localhost:3000/api\nENVIRONMENT=development\n```\n\n‚ö†Ô∏è **ANTI-PATTERNS TO AVOID:**\n- DO NOT use regular classes (use abstract final class)\n- DO NOT hardcode secrets in constants\n- DO NOT use dynamic types\n- DO NOT create instance methods (all static)\n\nüéØ **FUNCTIONAL REQUIREMENTS:**\n1. All constants accessible via ClassName.constantName\n2. EnvConfig reads from .env file with fallbacks\n3. No instantiation possible (abstract final class)\n4. All values are compile-time constants where possible\n\nüß™ **VERIFICATION:**\n```bash\nflutter analyze lib/core/constants/\nflutter analyze lib/env/\n```",
        "epicId": "epic-flutter-foundation",
        "priority": 2,
        "estimatedComplexity": "simple",
        "dependencies": [
          "epic-flutter-foundation-story-1"
        ],
        "status": "pending",
        "filesToRead": [
          "pubspec.yaml"
        ],
        "filesToModify": [],
        "filesToCreate": [
          "lib/core/constants/app_constants.dart",
          "lib/core/constants/api_endpoints.dart",
          "lib/env/env_config.dart",
          ".env.example"
        ],
        "acceptanceCriteria": [
          "Given app_constants.dart is created, When importing and accessing AppConstants.appName, Then it returns 'App Pasos'",
          "Given api_endpoints.dart is created, When accessing ApiEndpoints.login, Then it returns '/auth/login'",
          "Given env_config.dart is created, When calling EnvConfig.apiBaseUrl without .env, Then it returns the fallback URL",
          "Given .env.example is created, When copied to .env and loaded, Then EnvConfig reads values correctly"
        ]
      },
      {
        "id": "epic-flutter-foundation-story-3",
        "title": "Create lib/core/errors/exceptions.dart and lib/core/errors/failures.dart",
        "description": "**Description:**\nImplement a robust error handling layer with custom exceptions for runtime errors and Failure classes for functional error handling using the Either pattern.\n\nüîí **SCOPE BOUNDARY:**\n- You can ONLY create files listed below\n- Creating ANY other file is a scope violation\n\nüìÅ **FILES:**\n- Read: [pubspec.yaml](pubspec.yaml)\n- Modify: NONE\n- Create: [lib/core/errors/exceptions.dart](lib/core/errors/exceptions.dart), [lib/core/errors/failures.dart](lib/core/errors/failures.dart)\n\nüîß **PATTERNS TO USE:**\n- Extend Exception for custom exceptions\n- Extend Equatable for Failure classes (value equality)\n- Use sealed classes for Failure hierarchy (Dart 3 pattern)\n- Follow functional error handling (Either<Failure, Success>)\n\nüì¶ **REQUIRED IMPLEMENTATION:**\n\n**exceptions.dart:**\n```dart\n/// Base exception for all app exceptions\nclass AppException implements Exception {\n  final String message;\n  final int? statusCode;\n  final dynamic originalError;\n\n  const AppException({\n    required this.message,\n    this.statusCode,\n    this.originalError,\n  });\n\n  @override\n  String toString() => 'AppException: $message (status: $statusCode)';\n}\n\n/// Server-side errors (5xx, network issues)\nclass ServerException extends AppException {\n  const ServerException({required super.message, super.statusCode, super.originalError});\n}\n\n/// Client-side errors (4xx, validation)\nclass ClientException extends AppException {\n  const ClientException({required super.message, super.statusCode, super.originalError});\n}\n\n/// Cache/storage errors\nclass CacheException extends AppException {\n  const CacheException({required super.message, super.originalError});\n}\n\n/// Network connectivity errors\nclass NetworkException extends AppException {\n  const NetworkException({super.message = 'No internet connection', super.originalError});\n}\n\n/// Authentication errors\nclass AuthException extends AppException {\n  const AuthException({required super.message, super.statusCode, super.originalError});\n}\n```\n\n**failures.dart:**\n```dart\nimport 'package:equatable/equatable.dart';\n\n/// Base failure class for functional error handling\nsealed class Failure extends Equatable {\n  final String message;\n  final int? code;\n\n  const Failure({required this.message, this.code});\n\n  @override\n  List<Object?> get props => [message, code];\n}\n\n/// Server-side failures\nfinal class ServerFailure extends Failure {\n  const ServerFailure({required super.message, super.code});\n}\n\n/// Client-side failures (validation, bad request)\nfinal class ClientFailure extends Failure {\n  const ClientFailure({required super.message, super.code});\n}\n\n/// Cache failures\nfinal class CacheFailure extends Failure {\n  const CacheFailure({required super.message});\n}\n\n/// Network failures\nfinal class NetworkFailure extends Failure {\n  const NetworkFailure({super.message = 'No internet connection'});\n}\n\n/// Authentication failures\nfinal class AuthFailure extends Failure {\n  const AuthFailure({required super.message, super.code});\n}\n```\n\n‚ö†Ô∏è **ANTI-PATTERNS TO AVOID:**\n- DO NOT use generic Exception without custom types\n- DO NOT forget to extend Equatable for Failure\n- DO NOT use mutable fields (all final)\n- DO NOT catch generic Exception without mapping to Failure\n\nüéØ **FUNCTIONAL REQUIREMENTS:**\n1. All exceptions have message and optional statusCode\n2. All failures are Equatable (for comparison)\n3. Failures are sealed (exhaustive switch)\n4. Clear hierarchy: Base ‚Üí Specific types\n\nüß™ **VERIFICATION:**\n```bash\nflutter analyze lib/core/errors/\n```",
        "epicId": "epic-flutter-foundation",
        "priority": 2,
        "estimatedComplexity": "moderate",
        "dependencies": [
          "epic-flutter-foundation-story-1"
        ],
        "status": "pending",
        "filesToRead": [
          "pubspec.yaml"
        ],
        "filesToModify": [],
        "filesToCreate": [
          "lib/core/errors/exceptions.dart",
          "lib/core/errors/failures.dart"
        ],
        "acceptanceCriteria": [
          "Given exceptions.dart is created, When throwing ServerException, Then it includes message and statusCode",
          "Given failures.dart is created, When comparing two ServerFailure with same message, Then they are equal (Equatable)",
          "Given Failure is sealed, When using switch on Failure type, Then Dart requires all cases to be handled",
          "Given NetworkException is thrown, When converted to NetworkFailure, Then message is preserved"
        ]
      },
      {
        "id": "epic-flutter-foundation-story-4",
        "title": "Create lib/core/utils/logger.dart and lib/core/utils/validators.dart",
        "description": "**Description:**\nImplement utility classes for logging (wrapper around logger package) and common validation functions for forms and data.\n\nüîí **SCOPE BOUNDARY:**\n- You can ONLY create files listed below\n- Creating ANY other file is a scope violation\n\nüìÅ **FILES:**\n- Read: [pubspec.yaml](pubspec.yaml)\n- Modify: NONE\n- Create: [lib/core/utils/logger.dart](lib/core/utils/logger.dart), [lib/core/utils/validators.dart](lib/core/utils/validators.dart)\n\nüîß **PATTERNS TO USE:**\n- Singleton pattern for AppLogger\n- Static methods for Validators\n- Extension methods for String validation\n- Null safety with nullable returns\n\nüì¶ **REQUIRED IMPLEMENTATION:**\n\n**logger.dart:**\n```dart\nimport 'package:logger/logger.dart';\n\n/// Centralized logging utility\nclass AppLogger {\n  static final AppLogger _instance = AppLogger._internal();\n  factory AppLogger() => _instance;\n  AppLogger._internal();\n\n  final Logger _logger = Logger(\n    printer: PrettyPrinter(\n      methodCount: 2,\n      errorMethodCount: 8,\n      lineLength: 120,\n      colors: true,\n      printEmojis: true,\n      dateTimeFormat: DateTimeFormat.onlyTimeAndSinceStart,\n    ),\n  );\n\n  void debug(dynamic message, [dynamic error, StackTrace? stackTrace]) {\n    _logger.d(message, error: error, stackTrace: stackTrace);\n  }\n\n  void info(dynamic message, [dynamic error, StackTrace? stackTrace]) {\n    _logger.i(message, error: error, stackTrace: stackTrace);\n  }\n\n  void warning(dynamic message, [dynamic error, StackTrace? stackTrace]) {\n    _logger.w(message, error: error, stackTrace: stackTrace);\n  }\n\n  void error(dynamic message, [dynamic error, StackTrace? stackTrace]) {\n    _logger.e(message, error: error, stackTrace: stackTrace);\n  }\n\n  void fatal(dynamic message, [dynamic error, StackTrace? stackTrace]) {\n    _logger.f(message, error: error, stackTrace: stackTrace);\n  }\n}\n\n/// Global logger instance for convenience\nfinal appLogger = AppLogger();\n```\n\n**validators.dart:**\n```dart\n/// Validation utilities for forms and data\nabstract final class Validators {\n  /// Email validation regex\n  static final RegExp _emailRegex = RegExp(\n    r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$',\n  );\n\n  /// Password minimum length\n  static const int minPasswordLength = 8;\n\n  /// Validates email format\n  /// Returns error message or null if valid\n  static String? validateEmail(String? value) {\n    if (value == null || value.isEmpty) {\n      return 'Email is required';\n    }\n    if (!_emailRegex.hasMatch(value)) {\n      return 'Please enter a valid email';\n    }\n    return null;\n  }\n\n  /// Validates password strength\n  /// Returns error message or null if valid\n  static String? validatePassword(String? value) {\n    if (value == null || value.isEmpty) {\n      return 'Password is required';\n    }\n    if (value.length < minPasswordLength) {\n      return 'Password must be at least $minPasswordLength characters';\n    }\n    if (!value.contains(RegExp(r'[A-Z]'))) {\n      return 'Password must contain at least one uppercase letter';\n    }\n    if (!value.contains(RegExp(r'[0-9]'))) {\n      return 'Password must contain at least one number';\n    }\n    return null;\n  }\n\n  /// Validates required field\n  static String? validateRequired(String? value, [String fieldName = 'Field']) {\n    if (value == null || value.trim().isEmpty) {\n      return '$fieldName is required';\n    }\n    return null;\n  }\n\n  /// Validates phone number (basic)\n  static String? validatePhone(String? value) {\n    if (value == null || value.isEmpty) {\n      return 'Phone number is required';\n    }\n    final digitsOnly = value.replaceAll(RegExp(r'[^0-9]'), '');\n    if (digitsOnly.length < 10 || digitsOnly.length > 15) {\n      return 'Please enter a valid phone number';\n    }\n    return null;\n  }\n\n  /// Validates confirm password matches\n  static String? validateConfirmPassword(String? value, String? password) {\n    if (value == null || value.isEmpty) {\n      return 'Please confirm your password';\n    }\n    if (value != password) {\n      return 'Passwords do not match';\n    }\n    return null;\n  }\n}\n```\n\n‚ö†Ô∏è **ANTI-PATTERNS TO AVOID:**\n- DO NOT use print() for logging (use AppLogger)\n- DO NOT return bool from validators (return String? for error messages)\n- DO NOT make AppLogger non-singleton\n- DO NOT use dynamic types in validators\n\nüéØ **FUNCTIONAL REQUIREMENTS:**\n1. AppLogger is singleton with factory constructor\n2. All log levels available (debug, info, warning, error, fatal)\n3. Validators return null for valid, error message for invalid\n4. Validators work with Form widget validation\n\nüß™ **VERIFICATION:**\n```bash\nflutter analyze lib/core/utils/\n```",
        "epicId": "epic-flutter-foundation",
        "priority": 2,
        "estimatedComplexity": "moderate",
        "dependencies": [
          "epic-flutter-foundation-story-1"
        ],
        "status": "pending",
        "filesToRead": [
          "pubspec.yaml"
        ],
        "filesToModify": [],
        "filesToCreate": [
          "lib/core/utils/logger.dart",
          "lib/core/utils/validators.dart"
        ],
        "acceptanceCriteria": [
          "Given AppLogger is created, When calling appLogger.info('test'), Then message is logged with info level",
          "Given Validators.validateEmail is called with 'test@email.com', When validated, Then returns null (valid)",
          "Given Validators.validateEmail is called with 'invalid', When validated, Then returns error message",
          "Given Validators.validatePassword is called with 'Weak1', When validated, Then returns error about length"
        ]
      },
      {
        "id": "epic-flutter-foundation-story-5",
        "title": "Create lib/core/network/api_client.dart, lib/core/network/api_interceptor.dart, lib/core/network/network_info.dart, lib/core/di/injection_container.dart, lib/app.dart and update lib/main.dart",
        "description": "**Description:**\nImplement the network layer with Dio HTTP client, interceptors for logging/auth, network connectivity checker, dependency injection container using get_it, and refactored app structure with App widget.\n\nüîí **SCOPE BOUNDARY:**\n- You can ONLY create/modify files listed below\n- Creating ANY other file is a scope violation\n\nüìÅ **FILES:**\n- Read: [pubspec.yaml](pubspec.yaml), [lib/core/constants/app_constants.dart](lib/core/constants/app_constants.dart), [lib/core/constants/api_endpoints.dart](lib/core/constants/api_endpoints.dart), [lib/env/env_config.dart](lib/env/env_config.dart), [lib/core/errors/exceptions.dart](lib/core/errors/exceptions.dart), [lib/core/utils/logger.dart](lib/core/utils/logger.dart)\n- Modify: [lib/main.dart](lib/main.dart)\n- Create: [lib/core/network/api_client.dart](lib/core/network/api_client.dart), [lib/core/network/api_interceptor.dart](lib/core/network/api_interceptor.dart), [lib/core/network/network_info.dart](lib/core/network/network_info.dart), [lib/core/di/injection_container.dart](lib/core/di/injection_container.dart), [lib/app.dart](lib/app.dart)\n\nüîß **PATTERNS TO USE:**\n- Use get_it for dependency injection (sl = service locator)\n- Use Dio with interceptors for HTTP\n- Use connectivity_plus for network status\n- Follow clean architecture DI setup pattern\n\nüì¶ **REQUIRED IMPLEMENTATION:**\n\n**network_info.dart:**\n```dart\nimport 'package:connectivity_plus/connectivity_plus.dart';\n\nabstract class NetworkInfo {\n  Future<bool> get isConnected;\n  Stream<bool> get onConnectivityChanged;\n}\n\nclass NetworkInfoImpl implements NetworkInfo {\n  final Connectivity _connectivity;\n\n  NetworkInfoImpl(this._connectivity);\n\n  @override\n  Future<bool> get isConnected async {\n    final result = await _connectivity.checkConnectivity();\n    return !result.contains(ConnectivityResult.none);\n  }\n\n  @override\n  Stream<bool> get onConnectivityChanged {\n    return _connectivity.onConnectivityChanged.map(\n      (results) => !results.contains(ConnectivityResult.none),\n    );\n  }\n}\n```\n\n**api_interceptor.dart:**\n```dart\nimport 'package:dio/dio.dart';\nimport '../utils/logger.dart';\n\nclass LoggingInterceptor extends Interceptor {\n  @override\n  void onRequest(RequestOptions options, RequestInterceptorHandler handler) {\n    appLogger.info('REQUEST[${options.method}] => PATH: ${options.path}');\n    super.onRequest(options, handler);\n  }\n\n  @override\n  void onResponse(Response response, ResponseInterceptorHandler handler) {\n    appLogger.info('RESPONSE[${response.statusCode}] => PATH: ${response.requestOptions.path}');\n    super.onResponse(response, handler);\n  }\n\n  @override\n  void onError(DioException err, ErrorInterceptorHandler handler) {\n    appLogger.error('ERROR[${err.response?.statusCode}] => PATH: ${err.requestOptions.path}', err);\n    super.onError(err, handler);\n  }\n}\n\nclass AuthInterceptor extends Interceptor {\n  String? _accessToken;\n\n  void setToken(String? token) => _accessToken = token;\n  void clearToken() => _accessToken = null;\n\n  @override\n  void onRequest(RequestOptions options, RequestInterceptorHandler handler) {\n    if (_accessToken != null) {\n      options.headers['Authorization'] = 'Bearer $_accessToken';\n    }\n    super.onRequest(options, handler);\n  }\n}\n```\n\n**api_client.dart:**\n```dart\nimport 'package:dartz/dartz.dart';\nimport 'package:dio/dio.dart';\nimport '../constants/app_constants.dart';\nimport '../errors/exceptions.dart';\nimport '../errors/failures.dart';\nimport '../env/env_config.dart';\nimport 'api_interceptor.dart';\nimport 'network_info.dart';\n\nclass ApiClient {\n  final Dio _dio;\n  final NetworkInfo _networkInfo;\n  final AuthInterceptor authInterceptor;\n\n  ApiClient({\n    required Dio dio,\n    required NetworkInfo networkInfo,\n    required this.authInterceptor,\n  })  : _dio = dio,\n        _networkInfo = networkInfo {\n    _dio.options = BaseOptions(\n      baseUrl: EnvConfig.apiBaseUrl,\n      connectTimeout: AppConstants.connectionTimeout,\n      receiveTimeout: AppConstants.defaultTimeout,\n      headers: {'Content-Type': 'application/json'},\n    );\n    _dio.interceptors.addAll([LoggingInterceptor(), authInterceptor]);\n  }\n\n  Future<Either<Failure, T>> get<T>(\n    String path, {\n    Map<String, dynamic>? queryParameters,\n    required T Function(dynamic) fromJson,\n  }) async {\n    return _executeRequest(\n      () => _dio.get(path, queryParameters: queryParameters),\n      fromJson,\n    );\n  }\n\n  Future<Either<Failure, T>> post<T>(\n    String path, {\n    dynamic data,\n    required T Function(dynamic) fromJson,\n  }) async {\n    return _executeRequest(\n      () => _dio.post(path, data: data),\n      fromJson,\n    );\n  }\n\n  Future<Either<Failure, T>> _executeRequest<T>(\n    Future<Response> Function() request,\n    T Function(dynamic) fromJson,\n  ) async {\n    if (!await _networkInfo.isConnected) {\n      return const Left(NetworkFailure());\n    }\n    try {\n      final response = await request();\n      return Right(fromJson(response.data));\n    } on DioException catch (e) {\n      return Left(_handleDioError(e));\n    } catch (e) {\n      return Left(ServerFailure(message: e.toString()));\n    }\n  }\n\n  Failure _handleDioError(DioException e) {\n    switch (e.type) {\n      case DioExceptionType.connectionTimeout:\n      case DioExceptionType.receiveTimeout:\n      case DioExceptionType.sendTimeout:\n        return const ServerFailure(message: 'Connection timeout', code: 408);\n      case DioExceptionType.badResponse:\n        final statusCode = e.response?.statusCode ?? 500;\n        final message = e.response?.data?['message'] ?? 'Server error';\n        if (statusCode >= 400 && statusCode < 500) {\n          return ClientFailure(message: message, code: statusCode);\n        }\n        return ServerFailure(message: message, code: statusCode);\n      default:\n        return ServerFailure(message: e.message ?? 'Unknown error');\n    }\n  }\n}\n```\n\n**injection_container.dart:**\n```dart\nimport 'package:connectivity_plus/connectivity_plus.dart';\nimport 'package:dio/dio.dart';\nimport 'package:get_it/get_it.dart';\nimport '../network/api_client.dart';\nimport '../network/api_interceptor.dart';\nimport '../network/network_info.dart';\n\nfinal GetIt sl = GetIt.instance;\n\nFuture<void> initializeDependencies() async {\n  // Core\n  sl.registerLazySingleton<Connectivity>(() => Connectivity());\n  sl.registerLazySingleton<Dio>(() => Dio());\n  \n  // Network\n  sl.registerLazySingleton<NetworkInfo>(() => NetworkInfoImpl(sl()));\n  sl.registerLazySingleton<AuthInterceptor>(() => AuthInterceptor());\n  sl.registerLazySingleton<ApiClient>(\n    () => ApiClient(\n      dio: sl(),\n      networkInfo: sl(),\n      authInterceptor: sl(),\n    ),\n  );\n}\n```\n\n**app.dart:**\n```dart\nimport 'package:flutter/material.dart';\n\nclass App extends StatelessWidget {\n  const App({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'App Pasos',\n      debugShowCheckedModeBanner: false,\n      theme: ThemeData(\n        colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple),\n        useMaterial3: true,\n      ),\n      home: const Scaffold(\n        body: Center(\n          child: Text('App Pasos - Foundation Ready'),\n        ),\n      ),\n    );\n  }\n}\n```\n\n**main.dart (updated):**\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_dotenv/flutter_dotenv.dart';\nimport 'app.dart';\nimport 'core/di/injection_container.dart';\n\nFuture<void> main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  \n  // Load environment variables\n  await dotenv.load(fileName: '.env').catchError((_) {\n    // .env file not found, using defaults\n  });\n  \n  // Initialize dependencies\n  await initializeDependencies();\n  \n  runApp(const App());\n}\n```\n\n‚ö†Ô∏è **ANTI-PATTERNS TO AVOID:**\n- DO NOT use global Dio instance without DI\n- DO NOT hardcode base URL (use EnvConfig)\n- DO NOT catch exceptions without mapping to Failure\n- DO NOT initialize dependencies in widget build\n\nüéØ **FUNCTIONAL REQUIREMENTS:**\n1. ApiClient uses Either<Failure, T> for all responses\n2. NetworkInfo checks connectivity before requests\n3. All dependencies registered via get_it (sl)\n4. main.dart initializes env and DI before runApp\n5. App widget with Material3 theme\n\nüß™ **VERIFICATION:**\n```bash\nflutter analyze\nflutter build apk --debug\n```",
        "epicId": "epic-flutter-foundation",
        "priority": 3,
        "estimatedComplexity": "complex",
        "dependencies": [
          "epic-flutter-foundation-story-2",
          "epic-flutter-foundation-story-3",
          "epic-flutter-foundation-story-4"
        ],
        "status": "pending",
        "filesToRead": [
          "pubspec.yaml",
          "lib/core/constants/app_constants.dart",
          "lib/core/constants/api_endpoints.dart",
          "lib/env/env_config.dart",
          "lib/core/errors/exceptions.dart",
          "lib/core/errors/failures.dart",
          "lib/core/utils/logger.dart"
        ],
        "filesToModify": [
          "lib/main.dart"
        ],
        "filesToCreate": [
          "lib/core/network/api_client.dart",
          "lib/core/network/api_interceptor.dart",
          "lib/core/network/network_info.dart",
          "lib/core/di/injection_container.dart",
          "lib/app.dart"
        ],
        "acceptanceCriteria": [
          "Given injection_container.dart is created, When calling initializeDependencies(), Then all services are registered in get_it",
          "Given ApiClient is created, When making GET request without network, Then returns Left(NetworkFailure)",
          "Given main.dart is updated, When app starts, Then dotenv loads and DI initializes before runApp",
          "Given app.dart is created, When running flutter run, Then app displays 'App Pasos - Foundation Ready'"
        ]
      }
    ]
  }
}