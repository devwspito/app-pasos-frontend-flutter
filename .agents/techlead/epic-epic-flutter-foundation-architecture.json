{
  "_metadata": {
    "agentType": "techlead",
    "taskId": "cdbc860ca421a8660ccc0e0c",
    "timestamp": "2026-01-26T23:47:18.391Z",
    "phase": "techlead",
    "epicId": "epic-flutter-foundation",
    "savedAt": "2026-01-26T23:47:18.392Z",
    "version": "1.0"
  },
  "data": {
    "epicId": "epic-flutter-foundation",
    "storiesCount": 5,
    "architecture": "## Flutter Foundation Architecture\n\n### Architecture Pattern: Feature-Based Clean Architecture\n\n**Folder Structure:**\n```\nlib/\n‚îú‚îÄ‚îÄ core/                    # Shared infrastructure\n‚îÇ   ‚îú‚îÄ‚îÄ constants/           # App-wide constants\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ app_constants.dart\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ api_endpoints.dart\n‚îÇ   ‚îú‚îÄ‚îÄ config/              # Environment & app configuration\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ environment.dart\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ app_config.dart\n‚îÇ   ‚îú‚îÄ‚îÄ errors/              # Exception & failure classes\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ app_exceptions.dart\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ failure.dart\n‚îÇ   ‚îú‚îÄ‚îÄ network/             # HTTP client infrastructure\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dio_client.dart\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ api_interceptor.dart\n‚îÇ   ‚îî‚îÄ‚îÄ utils/               # Utilities\n‚îÇ       ‚îú‚îÄ‚îÄ logger.dart\n‚îÇ       ‚îî‚îÄ‚îÄ validators.dart\n‚îú‚îÄ‚îÄ data/                    # Data layer\n‚îÇ   ‚îú‚îÄ‚îÄ models/              # Data transfer objects\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user_model.dart\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ step_model.dart\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sharing_model.dart\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ goal_model.dart\n‚îÇ   ‚îî‚îÄ‚îÄ repositories/        # Repository implementations\n‚îÇ       ‚îî‚îÄ‚îÄ base_repository.dart\n‚îú‚îÄ‚îÄ injection_container.dart # Dependency injection setup\n‚îî‚îÄ‚îÄ main.dart                # App entry point\n```\n\n### Key Design Decisions:\n\n1. **Dependency Injection (get_it)**: Enables testability and loose coupling\n2. **Dio with Interceptors**: Centralized HTTP handling with auto-token refresh\n3. **FlutterSecureStorage**: Secure token storage with platform-specific encryption\n4. **Equatable Models**: Value equality for efficient widget rebuilds\n5. **json_serializable**: Type-safe JSON serialization with code generation\n6. **Exception/Failure Separation**: Exceptions for data layer, Failures for presentation\n\n### SOLID Compliance:\n- **SRP**: Each class has single responsibility (DioClient handles HTTP, ApiInterceptor handles auth)\n- **OCP**: BaseRepository can be extended without modification\n- **LSP**: All exceptions properly extend AppException\n- **ISP**: Small, focused interfaces (no bloated god classes)\n- **DIP**: All dependencies injected via get_it, depend on abstractions\n\n### Backend Integration Contract:\n- Base URL: Configured via EnvironmentConfig (dev: localhost:3001/api)\n- Auth: Bearer token in Authorization header\n- Token Refresh: POST /auth/refresh with refreshToken\n- All models match backend MongoDB schemas exactly",
    "stories": [
      {
        "id": "epic-flutter-foundation-story-1",
        "title": "Configure pubspec.yaml with provider, dio, go_router, flutter_secure_storage, get_it dependencies",
        "description": "Add all required dependencies to pubspec.yaml for the app foundation.\n\nüîí **SCOPE BOUNDARY:**\n- You can ONLY modify pubspec.yaml\n- Do NOT create any Dart files in this story\n\nüìÅ **FILES:**\n- Read: pubspec.yaml (current state)\n- Modify: pubspec.yaml\n- Create: NONE\n\nüîß **DEPENDENCIES TO ADD:**\n```yaml\ndependencies:\n  # State Management\n  provider: ^6.1.1\n  \n  # HTTP Client\n  dio: ^5.4.0\n  \n  # Routing\n  go_router: ^13.0.0\n  \n  # Secure Storage\n  flutter_secure_storage: ^9.0.0\n  \n  # Dependency Injection\n  get_it: ^7.6.4\n  \n  # JSON Serialization\n  json_annotation: ^4.8.1\n  \n  # Utilities\n  equatable: ^2.0.5\n  intl: ^0.18.1\n  logger: ^2.0.2+1\n\ndev_dependencies:\n  build_runner: ^2.4.7\n  json_serializable: ^6.7.1\n```\n\n‚ö†Ô∏è **ANTI-PATTERNS TO AVOID:**\n- Adding firebase_messaging without Firebase setup (skip for now)\n- Adding health package without platform-specific setup (skip for now)\n- Adding web_socket_channel (not needed for foundation)\n\nüéØ **FUNCTIONAL REQUIREMENTS:**\n- All dependencies must have compatible versions\n- SDK constraint remains ^3.5.0\n- Keep existing flutter_lints dev dependency\n\nüß™ **VERIFICATION:**\n```bash\nflutter pub get\nflutter analyze\n```",
        "epicId": "epic-flutter-foundation",
        "priority": 1,
        "estimatedComplexity": "simple",
        "dependencies": [],
        "status": "pending",
        "filesToRead": [
          "pubspec.yaml"
        ],
        "filesToModify": [
          "pubspec.yaml"
        ],
        "filesToCreate": [],
        "acceptanceCriteria": [
          "Given pubspec.yaml exists, When dependencies are added, Then flutter pub get succeeds without errors",
          "Given dependencies are added, When flutter analyze runs, Then no dependency conflicts are reported",
          "Given provider, dio, go_router, flutter_secure_storage, get_it are added, When checking pubspec.yaml, Then all five packages are listed with compatible versions"
        ]
      },
      {
        "id": "epic-flutter-foundation-story-2",
        "title": "Create lib/core/ folder with app_constants.dart, api_endpoints.dart, environment.dart, app_config.dart, logger.dart, validators.dart, app_exceptions.dart, failure.dart",
        "description": "Create the core folder structure with all constants, config, utils, and error handling files.\n\nüîí **SCOPE BOUNDARY:**\n- You can ONLY create files listed below\n- Do NOT modify pubspec.yaml or lib/main.dart\n\nüìÅ **FILES:**\n- Read: NONE\n- Modify: NONE\n- Create:\n  - lib/core/constants/app_constants.dart\n  - lib/core/constants/api_endpoints.dart\n  - lib/core/config/environment.dart\n  - lib/core/config/app_config.dart\n  - lib/core/utils/logger.dart\n  - lib/core/utils/validators.dart\n  - lib/core/errors/app_exceptions.dart\n  - lib/core/errors/failure.dart\n\nüîß **IMPLEMENTATION DETAILS:**\n\n**app_constants.dart:**\n```dart\nclass AppConstants {\n  static const String appName = 'App Pasos';\n  static const int defaultTimeout = 30000;\n  static const int maxStepsPerDay = 100000;\n  static const int minPasswordLength = 6;\n  static const int maxUsernameLength = 30;\n}\n```\n\n**api_endpoints.dart:**\n```dart\nclass ApiEndpoints {\n  // Auth\n  static const String register = '/auth/register';\n  static const String login = '/auth/login';\n  static const String refresh = '/auth/refresh';\n  static const String me = '/auth/me';\n  \n  // Steps\n  static const String steps = '/steps';\n  static const String stepsToday = '/steps/today';\n  static const String stepsWeekly = '/steps/weekly';\n  static const String stepsHourlyPeaks = '/steps/hourly-peaks';\n  static const String stepsStats = '/steps/stats';\n  \n  // Sharing\n  static const String sharingRequest = '/sharing/request';\n  static String sharingAccept(String id) => '/sharing/$id/accept';\n  static String sharingReject(String id) => '/sharing/$id/reject';\n  static String sharingDelete(String id) => '/sharing/$id';\n  static const String sharingList = '/sharing';\n  static String sharingUserStats(String userId) => '/sharing/$userId/stats';\n  \n  // Goals\n  static const String goals = '/goals';\n  static String goalById(String id) => '/goals/$id';\n  static String goalInvite(String id) => '/goals/$id/invite';\n  static String goalJoin(String id) => '/goals/$id/join';\n  static String goalLeave(String id) => '/goals/$id/leave';\n  static String goalProgress(String id) => '/goals/$id/progress';\n  \n  // Users\n  static const String usersSearch = '/users/search';\n  static String checkUsername(String username) => '/users/check/username/$username';\n  static String checkEmail(String email) => '/users/check/email/$email';\n  static String userByUsername(String username) => '/users/username/$username';\n  static String userById(String id) => '/users/$id';\n}\n```\n\n**environment.dart:**\n```dart\nenum Environment { development, staging, production }\n\nclass EnvironmentConfig {\n  final Environment environment;\n  final String baseUrl;\n  final bool enableLogging;\n  \n  const EnvironmentConfig({\n    required this.environment,\n    required this.baseUrl,\n    required this.enableLogging,\n  });\n  \n  static const EnvironmentConfig development = EnvironmentConfig(\n    environment: Environment.development,\n    baseUrl: 'http://localhost:3001/api',\n    enableLogging: true,\n  );\n  \n  static const EnvironmentConfig staging = EnvironmentConfig(\n    environment: Environment.staging,\n    baseUrl: 'https://staging-api.apppasos.com/api',\n    enableLogging: true,\n  );\n  \n  static const EnvironmentConfig production = EnvironmentConfig(\n    environment: Environment.production,\n    baseUrl: 'https://api.apppasos.com/api',\n    enableLogging: false,\n  );\n}\n```\n\n**app_config.dart:**\n```dart\nimport 'environment.dart';\n\nclass AppConfig {\n  static late EnvironmentConfig _config;\n  \n  static void init(EnvironmentConfig config) {\n    _config = config;\n  }\n  \n  static EnvironmentConfig get config => _config;\n  static String get baseUrl => _config.baseUrl;\n  static bool get enableLogging => _config.enableLogging;\n  static Environment get environment => _config.environment;\n  static bool get isDevelopment => _config.environment == Environment.development;\n  static bool get isProduction => _config.environment == Environment.production;\n}\n```\n\n**logger.dart:**\n```dart\nimport 'package:logger/logger.dart' as log_pkg;\nimport '../config/app_config.dart';\n\nclass AppLogger {\n  static late log_pkg.Logger _logger;\n  \n  static void init() {\n    _logger = log_pkg.Logger(\n      printer: log_pkg.PrettyPrinter(\n        methodCount: 2,\n        errorMethodCount: 8,\n        lineLength: 120,\n        colors: true,\n        printEmojis: true,\n        printTime: true,\n      ),\n      level: AppConfig.enableLogging ? log_pkg.Level.debug : log_pkg.Level.off,\n    );\n  }\n  \n  static void d(String message, [dynamic error, StackTrace? stackTrace]) {\n    _logger.d(message, error: error, stackTrace: stackTrace);\n  }\n  \n  static void i(String message, [dynamic error, StackTrace? stackTrace]) {\n    _logger.i(message, error: error, stackTrace: stackTrace);\n  }\n  \n  static void w(String message, [dynamic error, StackTrace? stackTrace]) {\n    _logger.w(message, error: error, stackTrace: stackTrace);\n  }\n  \n  static void e(String message, [dynamic error, StackTrace? stackTrace]) {\n    _logger.e(message, error: error, stackTrace: stackTrace);\n  }\n}\n```\n\n**validators.dart:**\n```dart\nimport '../constants/app_constants.dart';\n\nclass Validators {\n  static final RegExp _emailRegex = RegExp(r'^\\S+@\\S+\\.\\S+$');\n  static final RegExp _dateRegex = RegExp(r'^\\d{4}-\\d{2}-\\d{2}$');\n  \n  static String? validateEmail(String? value) {\n    if (value == null || value.isEmpty) {\n      return 'Email is required';\n    }\n    if (!_emailRegex.hasMatch(value)) {\n      return 'Please enter a valid email';\n    }\n    return null;\n  }\n  \n  static String? validatePassword(String? value) {\n    if (value == null || value.isEmpty) {\n      return 'Password is required';\n    }\n    if (value.length < AppConstants.minPasswordLength) {\n      return 'Password must be at least ${AppConstants.minPasswordLength} characters';\n    }\n    return null;\n  }\n  \n  static String? validateUsername(String? value) {\n    if (value == null || value.isEmpty) {\n      return 'Username is required';\n    }\n    if (value.length < 3) {\n      return 'Username must be at least 3 characters';\n    }\n    if (value.length > AppConstants.maxUsernameLength) {\n      return 'Username cannot exceed ${AppConstants.maxUsernameLength} characters';\n    }\n    return null;\n  }\n  \n  static String? validateStepCount(int? value) {\n    if (value == null) {\n      return 'Step count is required';\n    }\n    if (value < 0) {\n      return 'Step count cannot be negative';\n    }\n    if (value > AppConstants.maxStepsPerDay) {\n      return 'Step count exceeds maximum allowed';\n    }\n    return null;\n  }\n  \n  static bool isValidDateFormat(String date) {\n    return _dateRegex.hasMatch(date);\n  }\n}\n```\n\n**app_exceptions.dart:**\n```dart\nclass AppException implements Exception {\n  final String message;\n  final String? code;\n  final dynamic originalError;\n  \n  const AppException({\n    required this.message,\n    this.code,\n    this.originalError,\n  });\n  \n  @override\n  String toString() => 'AppException: $message (code: $code)';\n}\n\nclass NetworkException extends AppException {\n  const NetworkException({required super.message, super.code, super.originalError});\n}\n\nclass AuthException extends AppException {\n  const AuthException({required super.message, super.code, super.originalError});\n}\n\nclass ValidationException extends AppException {\n  const ValidationException({required super.message, super.code, super.originalError});\n}\n\nclass ServerException extends AppException {\n  final int? statusCode;\n  \n  const ServerException({\n    required super.message,\n    super.code,\n    super.originalError,\n    this.statusCode,\n  });\n}\n\nclass CacheException extends AppException {\n  const CacheException({required super.message, super.code, super.originalError});\n}\n```\n\n**failure.dart:**\n```dart\nimport 'package:equatable/equatable.dart';\n\nabstract class Failure extends Equatable {\n  final String message;\n  final String? code;\n  \n  const Failure({required this.message, this.code});\n  \n  @override\n  List<Object?> get props => [message, code];\n}\n\nclass NetworkFailure extends Failure {\n  const NetworkFailure({required super.message, super.code});\n}\n\nclass AuthFailure extends Failure {\n  const AuthFailure({required super.message, super.code});\n}\n\nclass ServerFailure extends Failure {\n  final int? statusCode;\n  \n  const ServerFailure({required super.message, super.code, this.statusCode});\n  \n  @override\n  List<Object?> get props => [message, code, statusCode];\n}\n\nclass ValidationFailure extends Failure {\n  const ValidationFailure({required super.message, super.code});\n}\n\nclass CacheFailure extends Failure {\n  const CacheFailure({required super.message, super.code});\n}\n```\n\n‚ö†Ô∏è **ANTI-PATTERNS TO AVOID:**\n- Using print() instead of AppLogger ‚Üê WRONG\n- Hardcoding API base URLs in multiple places ‚Üê WRONG\n- Creating generic \"Error\" classes without specificity ‚Üê WRONG\n\nüß™ **VERIFICATION:**\n```bash\nflutter analyze lib/core/\n```",
        "epicId": "epic-flutter-foundation",
        "priority": 2,
        "estimatedComplexity": "moderate",
        "dependencies": [
          "epic-flutter-foundation-story-1"
        ],
        "status": "pending",
        "filesToRead": [],
        "filesToModify": [],
        "filesToCreate": [
          "lib/core/constants/app_constants.dart",
          "lib/core/constants/api_endpoints.dart",
          "lib/core/config/environment.dart",
          "lib/core/config/app_config.dart",
          "lib/core/utils/logger.dart",
          "lib/core/utils/validators.dart",
          "lib/core/errors/app_exceptions.dart",
          "lib/core/errors/failure.dart"
        ],
        "acceptanceCriteria": [
          "Given lib/core/ folder structure is created, When flutter analyze runs, Then no errors are reported for any core files",
          "Given ApiEndpoints class exists, When checking endpoints, Then all backend API paths match: /auth/*, /steps/*, /sharing/*, /goals/*, /users/*",
          "Given Validators class exists, When validating email 'test@example.com', Then validation passes",
          "Given AppException hierarchy exists, When creating NetworkException, Then it properly extends AppException"
        ]
      },
      {
        "id": "epic-flutter-foundation-story-3",
        "title": "Create lib/core/network/dio_client.dart and api_interceptor.dart with token injection and refresh handling",
        "description": "Implement Dio HTTP client with authentication interceptor for token management.\n\nüîí **SCOPE BOUNDARY:**\n- You can ONLY create files listed below\n- Do NOT modify any existing files\n- Do NOT create files in lib/core/config/ or lib/core/errors/\n\nüìÅ **FILES:**\n- Read: NONE (story-2 creates the config/error files you'll import)\n- Modify: NONE\n- Create:\n  - lib/core/network/dio_client.dart\n  - lib/core/network/api_interceptor.dart\n\nüîß **IMPLEMENTATION DETAILS:**\n\n**api_interceptor.dart:**\n```dart\nimport 'package:dio/dio.dart';\nimport 'package:flutter_secure_storage/flutter_secure_storage.dart';\nimport '../utils/logger.dart';\nimport '../config/app_config.dart';\n\nclass ApiInterceptor extends Interceptor {\n  final FlutterSecureStorage _secureStorage;\n  final Dio _dio;\n  \n  static const String _accessTokenKey = 'access_token';\n  static const String _refreshTokenKey = 'refresh_token';\n  \n  ApiInterceptor({\n    required FlutterSecureStorage secureStorage,\n    required Dio dio,\n  })  : _secureStorage = secureStorage,\n        _dio = dio;\n  \n  @override\n  void onRequest(\n    RequestOptions options,\n    RequestInterceptorHandler handler,\n  ) async {\n    final token = await _secureStorage.read(key: _accessTokenKey);\n    \n    if (token != null) {\n      options.headers['Authorization'] = 'Bearer $token';\n    }\n    \n    if (AppConfig.enableLogging) {\n      AppLogger.d('REQUEST[${options.method}] => PATH: ${options.path}');\n    }\n    \n    return handler.next(options);\n  }\n  \n  @override\n  void onResponse(\n    Response response,\n    ResponseInterceptorHandler handler,\n  ) {\n    if (AppConfig.enableLogging) {\n      AppLogger.d(\n        'RESPONSE[${response.statusCode}] => PATH: ${response.requestOptions.path}',\n      );\n    }\n    return handler.next(response);\n  }\n  \n  @override\n  void onError(\n    DioException err,\n    ErrorInterceptorHandler handler,\n  ) async {\n    if (AppConfig.enableLogging) {\n      AppLogger.e(\n        'ERROR[${err.response?.statusCode}] => PATH: ${err.requestOptions.path}',\n        err,\n      );\n    }\n    \n    if (err.response?.statusCode == 401) {\n      final refreshed = await _refreshToken();\n      if (refreshed) {\n        final response = await _retryRequest(err.requestOptions);\n        return handler.resolve(response);\n      }\n    }\n    \n    return handler.next(err);\n  }\n  \n  Future<bool> _refreshToken() async {\n    try {\n      final refreshToken = await _secureStorage.read(key: _refreshTokenKey);\n      if (refreshToken == null) return false;\n      \n      final response = await _dio.post(\n        '/auth/refresh',\n        data: {'refreshToken': refreshToken},\n        options: Options(headers: {'skipAuthInterceptor': true}),\n      );\n      \n      if (response.statusCode == 200) {\n        final newAccessToken = response.data['accessToken'];\n        final newRefreshToken = response.data['refreshToken'];\n        \n        await _secureStorage.write(key: _accessTokenKey, value: newAccessToken);\n        if (newRefreshToken != null) {\n          await _secureStorage.write(key: _refreshTokenKey, value: newRefreshToken);\n        }\n        return true;\n      }\n    } catch (e) {\n      AppLogger.e('Token refresh failed', e);\n      await clearTokens();\n    }\n    return false;\n  }\n  \n  Future<Response<dynamic>> _retryRequest(RequestOptions requestOptions) async {\n    final token = await _secureStorage.read(key: _accessTokenKey);\n    final options = Options(\n      method: requestOptions.method,\n      headers: {\n        ...requestOptions.headers,\n        'Authorization': 'Bearer $token',\n      },\n    );\n    \n    return _dio.request(\n      requestOptions.path,\n      data: requestOptions.data,\n      queryParameters: requestOptions.queryParameters,\n      options: options,\n    );\n  }\n  \n  Future<void> saveTokens(String accessToken, String refreshToken) async {\n    await _secureStorage.write(key: _accessTokenKey, value: accessToken);\n    await _secureStorage.write(key: _refreshTokenKey, value: refreshToken);\n  }\n  \n  Future<void> clearTokens() async {\n    await _secureStorage.delete(key: _accessTokenKey);\n    await _secureStorage.delete(key: _refreshTokenKey);\n  }\n  \n  Future<String?> getAccessToken() async {\n    return _secureStorage.read(key: _accessTokenKey);\n  }\n  \n  Future<bool> hasValidToken() async {\n    final token = await _secureStorage.read(key: _accessTokenKey);\n    return token != null;\n  }\n}\n```\n\n**dio_client.dart:**\n```dart\nimport 'package:dio/dio.dart';\nimport 'package:flutter_secure_storage/flutter_secure_storage.dart';\nimport '../config/app_config.dart';\nimport '../constants/app_constants.dart';\nimport '../errors/app_exceptions.dart';\nimport 'api_interceptor.dart';\n\nclass DioClient {\n  late final Dio _dio;\n  late final ApiInterceptor _apiInterceptor;\n  \n  DioClient({required FlutterSecureStorage secureStorage}) {\n    _dio = Dio(\n      BaseOptions(\n        baseUrl: AppConfig.baseUrl,\n        connectTimeout: Duration(milliseconds: AppConstants.defaultTimeout),\n        receiveTimeout: Duration(milliseconds: AppConstants.defaultTimeout),\n        headers: {\n          'Content-Type': 'application/json',\n          'Accept': 'application/json',\n        },\n      ),\n    );\n    \n    _apiInterceptor = ApiInterceptor(\n      secureStorage: secureStorage,\n      dio: _dio,\n    );\n    \n    _dio.interceptors.add(_apiInterceptor);\n  }\n  \n  ApiInterceptor get apiInterceptor => _apiInterceptor;\n  \n  Future<Response<T>> get<T>(\n    String path, {\n    Map<String, dynamic>? queryParameters,\n    Options? options,\n  }) async {\n    try {\n      return await _dio.get<T>(\n        path,\n        queryParameters: queryParameters,\n        options: options,\n      );\n    } on DioException catch (e) {\n      throw _handleDioError(e);\n    }\n  }\n  \n  Future<Response<T>> post<T>(\n    String path, {\n    dynamic data,\n    Map<String, dynamic>? queryParameters,\n    Options? options,\n  }) async {\n    try {\n      return await _dio.post<T>(\n        path,\n        data: data,\n        queryParameters: queryParameters,\n        options: options,\n      );\n    } on DioException catch (e) {\n      throw _handleDioError(e);\n    }\n  }\n  \n  Future<Response<T>> put<T>(\n    String path, {\n    dynamic data,\n    Map<String, dynamic>? queryParameters,\n    Options? options,\n  }) async {\n    try {\n      return await _dio.put<T>(\n        path,\n        data: data,\n        queryParameters: queryParameters,\n        options: options,\n      );\n    } on DioException catch (e) {\n      throw _handleDioError(e);\n    }\n  }\n  \n  Future<Response<T>> delete<T>(\n    String path, {\n    dynamic data,\n    Map<String, dynamic>? queryParameters,\n    Options? options,\n  }) async {\n    try {\n      return await _dio.delete<T>(\n        path,\n        data: data,\n        queryParameters: queryParameters,\n        options: options,\n      );\n    } on DioException catch (e) {\n      throw _handleDioError(e);\n    }\n  }\n  \n  AppException _handleDioError(DioException error) {\n    switch (error.type) {\n      case DioExceptionType.connectionTimeout:\n      case DioExceptionType.sendTimeout:\n      case DioExceptionType.receiveTimeout:\n        return NetworkException(\n          message: 'Connection timeout. Please check your internet connection.',\n          code: 'TIMEOUT',\n          originalError: error,\n        );\n      case DioExceptionType.connectionError:\n        return NetworkException(\n          message: 'No internet connection. Please check your network.',\n          code: 'NO_CONNECTION',\n          originalError: error,\n        );\n      case DioExceptionType.badResponse:\n        return _handleBadResponse(error);\n      case DioExceptionType.cancel:\n        return NetworkException(\n          message: 'Request was cancelled.',\n          code: 'CANCELLED',\n          originalError: error,\n        );\n      default:\n        return NetworkException(\n          message: 'An unexpected error occurred.',\n          code: 'UNKNOWN',\n          originalError: error,\n        );\n    }\n  }\n  \n  AppException _handleBadResponse(DioException error) {\n    final statusCode = error.response?.statusCode;\n    final data = error.response?.data;\n    final message = data is Map ? data['message'] ?? data['error'] : 'Server error';\n    \n    if (statusCode == 401) {\n      return AuthException(\n        message: message ?? 'Unauthorized. Please login again.',\n        code: 'UNAUTHORIZED',\n        originalError: error,\n      );\n    }\n    \n    if (statusCode == 403) {\n      return AuthException(\n        message: message ?? 'Access forbidden.',\n        code: 'FORBIDDEN',\n        originalError: error,\n      );\n    }\n    \n    if (statusCode == 404) {\n      return ServerException(\n        message: message ?? 'Resource not found.',\n        code: 'NOT_FOUND',\n        statusCode: statusCode,\n        originalError: error,\n      );\n    }\n    \n    if (statusCode == 422 || statusCode == 400) {\n      return ValidationException(\n        message: message ?? 'Invalid data provided.',\n        code: 'VALIDATION_ERROR',\n        originalError: error,\n      );\n    }\n    \n    return ServerException(\n      message: message ?? 'Server error occurred.',\n      code: 'SERVER_ERROR',\n      statusCode: statusCode,\n      originalError: error,\n    );\n  }\n}\n```\n\n‚ö†Ô∏è **ANTI-PATTERNS TO AVOID:**\n- Creating Dio instance without interceptors ‚Üê WRONG\n- Storing tokens in SharedPreferences instead of FlutterSecureStorage ‚Üê SECURITY RISK\n- Not handling token refresh on 401 ‚Üê WRONG\n- Hardcoding base URL instead of using AppConfig ‚Üê WRONG\n\nüéØ **FUNCTIONAL REQUIREMENTS:**\n- Automatic token injection on all requests\n- Automatic token refresh on 401 responses\n- Proper error mapping to AppException hierarchy\n- Configurable timeout from AppConstants\n\nüß™ **VERIFICATION:**\n```bash\nflutter analyze lib/core/network/\n```",
        "epicId": "epic-flutter-foundation",
        "priority": 3,
        "estimatedComplexity": "moderate",
        "dependencies": [
          "epic-flutter-foundation-story-2"
        ],
        "status": "pending",
        "filesToRead": [],
        "filesToModify": [],
        "filesToCreate": [
          "lib/core/network/dio_client.dart",
          "lib/core/network/api_interceptor.dart"
        ],
        "acceptanceCriteria": [
          "Given DioClient is instantiated, When checking configuration, Then baseUrl matches AppConfig.baseUrl",
          "Given ApiInterceptor is attached, When making a request with saved token, Then Authorization header is added",
          "Given a 401 response is received, When interceptor handles it, Then token refresh is attempted before failing",
          "Given DioException occurs, When handling error, Then appropriate AppException subtype is thrown"
        ]
      },
      {
        "id": "epic-flutter-foundation-story-4",
        "title": "Create lib/data/models/user_model.dart, step_model.dart, sharing_model.dart, goal_model.dart with JSON serialization",
        "description": "Create Dart data models matching the backend MongoDB schemas with JSON serialization.\n\nüîí **SCOPE BOUNDARY:**\n- You can ONLY create model files listed below\n- Do NOT create repository files\n- Do NOT modify any existing files\n\nüìÅ **FILES:**\n- Read: Backend models for reference (already analyzed)\n- Modify: NONE\n- Create:\n  - lib/data/models/user_model.dart\n  - lib/data/models/step_model.dart\n  - lib/data/models/sharing_model.dart\n  - lib/data/models/goal_model.dart\n\nüîß **PATTERNS TO USE:**\n- Use json_annotation for serialization\n- Use equatable for value equality\n- Match EXACT field names from backend\n- Use enums for status fields\n\nüì¶ **BACKEND SCHEMA REFERENCE:**\n- User: _id, username, email, password(excluded), createdAt, updatedAt\n- Step: _id, userId, count, timestamp, source(native|manual|web), hour, date, createdAt, updatedAt\n- SharingRelationship: _id, requesterId, targetId, status(pending|accepted|bidirectional|rejected), createdAt, acceptedAt\n- GroupGoal: _id, title, description, targetSteps, startDate, endDate, creatorId, createdAt, updatedAt\n- GroupGoalMembership: _id, goalId, userId, joinedAt, status(pending|active|left), createdAt, updatedAt\n\n**user_model.dart:**\n```dart\nimport 'package:equatable/equatable.dart';\nimport 'package:json_annotation/json_annotation.dart';\n\npart 'user_model.g.dart';\n\n@JsonSerializable()\nclass UserModel extends Equatable {\n  @JsonKey(name: '_id')\n  final String id;\n  final String username;\n  final String email;\n  final DateTime createdAt;\n  final DateTime updatedAt;\n\n  const UserModel({\n    required this.id,\n    required this.username,\n    required this.email,\n    required this.createdAt,\n    required this.updatedAt,\n  });\n\n  factory UserModel.fromJson(Map<String, dynamic> json) => _$UserModelFromJson(json);\n  Map<String, dynamic> toJson() => _$UserModelToJson(this);\n\n  @override\n  List<Object?> get props => [id, username, email, createdAt, updatedAt];\n  \n  UserModel copyWith({\n    String? id,\n    String? username,\n    String? email,\n    DateTime? createdAt,\n    DateTime? updatedAt,\n  }) {\n    return UserModel(\n      id: id ?? this.id,\n      username: username ?? this.username,\n      email: email ?? this.email,\n      createdAt: createdAt ?? this.createdAt,\n      updatedAt: updatedAt ?? this.updatedAt,\n    );\n  }\n}\n```\n\n**step_model.dart:**\n```dart\nimport 'package:equatable/equatable.dart';\nimport 'package:json_annotation/json_annotation.dart';\n\npart 'step_model.g.dart';\n\nenum StepSource {\n  @JsonValue('native')\n  native,\n  @JsonValue('manual')\n  manual,\n  @JsonValue('web')\n  web,\n}\n\n@JsonSerializable()\nclass StepModel extends Equatable {\n  @JsonKey(name: '_id')\n  final String? id;\n  final String userId;\n  final int count;\n  final DateTime timestamp;\n  final StepSource source;\n  final int hour;\n  final String date;\n  final DateTime? createdAt;\n  final DateTime? updatedAt;\n\n  const StepModel({\n    this.id,\n    required this.userId,\n    required this.count,\n    required this.timestamp,\n    required this.source,\n    required this.hour,\n    required this.date,\n    this.createdAt,\n    this.updatedAt,\n  });\n\n  factory StepModel.fromJson(Map<String, dynamic> json) => _$StepModelFromJson(json);\n  Map<String, dynamic> toJson() => _$StepModelToJson(this);\n\n  @override\n  List<Object?> get props => [id, userId, count, timestamp, source, hour, date];\n  \n  /// Create a new step for recording\n  factory StepModel.create({\n    required String userId,\n    required int count,\n    required StepSource source,\n    DateTime? timestamp,\n  }) {\n    final now = timestamp ?? DateTime.now();\n    return StepModel(\n      userId: userId,\n      count: count,\n      timestamp: now,\n      source: source,\n      hour: now.hour,\n      date: '${now.year}-${now.month.toString().padLeft(2, '0')}-${now.day.toString().padLeft(2, '0')}',\n    );\n  }\n}\n\n/// Response model for today's steps\n@JsonSerializable()\nclass TodayStepsResponse extends Equatable {\n  final int totalSteps;\n  final String date;\n  \n  const TodayStepsResponse({\n    required this.totalSteps,\n    required this.date,\n  });\n  \n  factory TodayStepsResponse.fromJson(Map<String, dynamic> json) => \n      _$TodayStepsResponseFromJson(json);\n  Map<String, dynamic> toJson() => _$TodayStepsResponseToJson(this);\n  \n  @override\n  List<Object?> get props => [totalSteps, date];\n}\n\n/// Response model for weekly trend\n@JsonSerializable()\nclass WeeklyTrendResponse extends Equatable {\n  final List<DailySteps> days;\n  final int totalSteps;\n  final double averageSteps;\n  \n  const WeeklyTrendResponse({\n    required this.days,\n    required this.totalSteps,\n    required this.averageSteps,\n  });\n  \n  factory WeeklyTrendResponse.fromJson(Map<String, dynamic> json) => \n      _$WeeklyTrendResponseFromJson(json);\n  Map<String, dynamic> toJson() => _$WeeklyTrendResponseToJson(this);\n  \n  @override\n  List<Object?> get props => [days, totalSteps, averageSteps];\n}\n\n@JsonSerializable()\nclass DailySteps extends Equatable {\n  final String date;\n  final int totalSteps;\n  \n  const DailySteps({required this.date, required this.totalSteps});\n  \n  factory DailySteps.fromJson(Map<String, dynamic> json) => _$DailyStepsFromJson(json);\n  Map<String, dynamic> toJson() => _$DailyStepsToJson(this);\n  \n  @override\n  List<Object?> get props => [date, totalSteps];\n}\n```\n\n**sharing_model.dart:**\n```dart\nimport 'package:equatable/equatable.dart';\nimport 'package:json_annotation/json_annotation.dart';\nimport 'user_model.dart';\n\npart 'sharing_model.g.dart';\n\nenum SharingStatus {\n  @JsonValue('pending')\n  pending,\n  @JsonValue('accepted')\n  accepted,\n  @JsonValue('bidirectional')\n  bidirectional,\n  @JsonValue('rejected')\n  rejected,\n}\n\n@JsonSerializable()\nclass SharingRelationshipModel extends Equatable {\n  @JsonKey(name: '_id')\n  final String id;\n  final String requesterId;\n  final String targetId;\n  final SharingStatus status;\n  final DateTime createdAt;\n  final DateTime? acceptedAt;\n  \n  // Populated user objects (when returned from API with .populate())\n  @JsonKey(includeIfNull: false)\n  final UserModel? requester;\n  @JsonKey(includeIfNull: false)\n  final UserModel? target;\n\n  const SharingRelationshipModel({\n    required this.id,\n    required this.requesterId,\n    required this.targetId,\n    required this.status,\n    required this.createdAt,\n    this.acceptedAt,\n    this.requester,\n    this.target,\n  });\n\n  factory SharingRelationshipModel.fromJson(Map<String, dynamic> json) => \n      _$SharingRelationshipModelFromJson(json);\n  Map<String, dynamic> toJson() => _$SharingRelationshipModelToJson(this);\n\n  @override\n  List<Object?> get props => [id, requesterId, targetId, status, createdAt, acceptedAt];\n  \n  bool get isPending => status == SharingStatus.pending;\n  bool get isAccepted => status == SharingStatus.accepted || status == SharingStatus.bidirectional;\n  bool get isBidirectional => status == SharingStatus.bidirectional;\n}\n\n/// Request model for creating a share request\n@JsonSerializable()\nclass CreateShareRequest extends Equatable {\n  final String targetId;\n  \n  const CreateShareRequest({required this.targetId});\n  \n  factory CreateShareRequest.fromJson(Map<String, dynamic> json) => \n      _$CreateShareRequestFromJson(json);\n  Map<String, dynamic> toJson() => _$CreateShareRequestToJson(this);\n  \n  @override\n  List<Object?> get props => [targetId];\n}\n```\n\n**goal_model.dart:**\n```dart\nimport 'package:equatable/equatable.dart';\nimport 'package:json_annotation/json_annotation.dart';\nimport 'user_model.dart';\n\npart 'goal_model.g.dart';\n\nenum MembershipStatus {\n  @JsonValue('pending')\n  pending,\n  @JsonValue('active')\n  active,\n  @JsonValue('left')\n  left,\n}\n\n@JsonSerializable()\nclass GroupGoalModel extends Equatable {\n  @JsonKey(name: '_id')\n  final String id;\n  final String title;\n  final String? description;\n  final int targetSteps;\n  final DateTime startDate;\n  final DateTime endDate;\n  final String creatorId;\n  final DateTime createdAt;\n  final DateTime updatedAt;\n  \n  // Populated creator (when returned from API)\n  @JsonKey(includeIfNull: false)\n  final UserModel? creator;\n  \n  // Members list (when returned with members)\n  @JsonKey(includeIfNull: false)\n  final List<GroupGoalMembershipModel>? members;\n\n  const GroupGoalModel({\n    required this.id,\n    required this.title,\n    this.description,\n    required this.targetSteps,\n    required this.startDate,\n    required this.endDate,\n    required this.creatorId,\n    required this.createdAt,\n    required this.updatedAt,\n    this.creator,\n    this.members,\n  });\n\n  factory GroupGoalModel.fromJson(Map<String, dynamic> json) => _$GroupGoalModelFromJson(json);\n  Map<String, dynamic> toJson() => _$GroupGoalModelToJson(this);\n\n  @override\n  List<Object?> get props => [\n        id,\n        title,\n        description,\n        targetSteps,\n        startDate,\n        endDate,\n        creatorId,\n        createdAt,\n        updatedAt,\n      ];\n  \n  bool get isActive {\n    final now = DateTime.now();\n    return now.isAfter(startDate) && now.isBefore(endDate);\n  }\n  \n  bool get isUpcoming => DateTime.now().isBefore(startDate);\n  bool get isCompleted => DateTime.now().isAfter(endDate);\n}\n\n@JsonSerializable()\nclass GroupGoalMembershipModel extends Equatable {\n  @JsonKey(name: '_id')\n  final String id;\n  final String goalId;\n  final String userId;\n  final DateTime joinedAt;\n  final MembershipStatus status;\n  final DateTime createdAt;\n  final DateTime updatedAt;\n  \n  // Populated user (when returned from API)\n  @JsonKey(includeIfNull: false)\n  final UserModel? user;\n\n  const GroupGoalMembershipModel({\n    required this.id,\n    required this.goalId,\n    required this.userId,\n    required this.joinedAt,\n    required this.status,\n    required this.createdAt,\n    required this.updatedAt,\n    this.user,\n  });\n\n  factory GroupGoalMembershipModel.fromJson(Map<String, dynamic> json) => \n      _$GroupGoalMembershipModelFromJson(json);\n  Map<String, dynamic> toJson() => _$GroupGoalMembershipModelToJson(this);\n\n  @override\n  List<Object?> get props => [id, goalId, userId, joinedAt, status];\n  \n  bool get isActive => status == MembershipStatus.active;\n  bool get isPending => status == MembershipStatus.pending;\n}\n\n/// Request model for creating a group goal\n@JsonSerializable()\nclass CreateGoalRequest extends Equatable {\n  final String title;\n  final String? description;\n  final int targetSteps;\n  final DateTime startDate;\n  final DateTime endDate;\n  \n  const CreateGoalRequest({\n    required this.title,\n    this.description,\n    required this.targetSteps,\n    required this.startDate,\n    required this.endDate,\n  });\n  \n  factory CreateGoalRequest.fromJson(Map<String, dynamic> json) => \n      _$CreateGoalRequestFromJson(json);\n  Map<String, dynamic> toJson() => _$CreateGoalRequestToJson(this);\n  \n  @override\n  List<Object?> get props => [title, description, targetSteps, startDate, endDate];\n}\n\n/// Request model for inviting a user to a goal\n@JsonSerializable()\nclass InviteToGoalRequest extends Equatable {\n  final String userId;\n  \n  const InviteToGoalRequest({required this.userId});\n  \n  factory InviteToGoalRequest.fromJson(Map<String, dynamic> json) => \n      _$InviteToGoalRequestFromJson(json);\n  Map<String, dynamic> toJson() => _$InviteToGoalRequestToJson(this);\n  \n  @override\n  List<Object?> get props => [userId];\n}\n\n/// Response model for goal progress\n@JsonSerializable()\nclass GoalProgressResponse extends Equatable {\n  final String goalId;\n  final int targetSteps;\n  final int totalSteps;\n  final double progressPercentage;\n  final List<MemberProgress> memberProgress;\n  \n  const GoalProgressResponse({\n    required this.goalId,\n    required this.targetSteps,\n    required this.totalSteps,\n    required this.progressPercentage,\n    required this.memberProgress,\n  });\n  \n  factory GoalProgressResponse.fromJson(Map<String, dynamic> json) => \n      _$GoalProgressResponseFromJson(json);\n  Map<String, dynamic> toJson() => _$GoalProgressResponseToJson(this);\n  \n  @override\n  List<Object?> get props => [goalId, targetSteps, totalSteps, progressPercentage];\n}\n\n@JsonSerializable()\nclass MemberProgress extends Equatable {\n  final String odId;\n  final String username;\n  final int steps;\n  final double contribution;\n  \n  const MemberProgress({\n    required this.userId,\n    required this.username,\n    required this.steps,\n    required this.contribution,\n  });\n  \n  factory MemberProgress.fromJson(Map<String, dynamic> json) => \n      _$MemberProgressFromJson(json);\n  Map<String, dynamic> toJson() => _$MemberProgressToJson(this);\n  \n  @override\n  List<Object?> get props => [userId, username, steps, contribution];\n}\n```\n\n‚ö†Ô∏è **ANTI-PATTERNS TO AVOID:**\n- Using `id` instead of `_id` for MongoDB documents ‚Üê WRONG (use @JsonKey)\n- Not using enums for status fields ‚Üê WRONG\n- Forgetting `part` directive for generated files ‚Üê BUILD WILL FAIL\n- Using dynamic types instead of proper Dart types ‚Üê WRONG\n\nüß™ **VERIFICATION:**\n```bash\nflutter pub run build_runner build --delete-conflicting-outputs\nflutter analyze lib/data/models/\n```\n\n**NOTE:** The .g.dart files will be generated by build_runner. Don't create them manually.",
        "epicId": "epic-flutter-foundation",
        "priority": 4,
        "estimatedComplexity": "moderate",
        "dependencies": [
          "epic-flutter-foundation-story-1"
        ],
        "status": "pending",
        "filesToRead": [],
        "filesToModify": [],
        "filesToCreate": [
          "lib/data/models/user_model.dart",
          "lib/data/models/step_model.dart",
          "lib/data/models/sharing_model.dart",
          "lib/data/models/goal_model.dart"
        ],
        "acceptanceCriteria": [
          "Given UserModel class exists, When serializing from JSON with _id field, Then id property is correctly mapped",
          "Given StepSource enum exists, When parsing 'native' from JSON, Then StepSource.native is returned",
          "Given SharingStatus enum exists, When values are checked, Then all four statuses match backend: pending, accepted, bidirectional, rejected",
          "Given build_runner runs, When processing models, Then .g.dart files are generated without errors"
        ]
      },
      {
        "id": "epic-flutter-foundation-story-5",
        "title": "Create lib/injection_container.dart with get_it setup and lib/data/repositories/base_repository.dart, modify lib/main.dart for initialization",
        "description": "Setup dependency injection container using get_it and create base repository pattern.\n\nüîí **SCOPE BOUNDARY:**\n- You can ONLY create/modify files listed below\n- Do NOT modify core/* files\n\nüìÅ **FILES:**\n- Read: lib/main.dart (current state)\n- Modify: lib/main.dart\n- Create:\n  - lib/injection_container.dart\n  - lib/data/repositories/base_repository.dart\n\nüîß **IMPLEMENTATION DETAILS:**\n\n**base_repository.dart:**\n```dart\nimport 'package:dio/dio.dart';\nimport '../../core/errors/app_exceptions.dart';\nimport '../../core/errors/failure.dart';\nimport '../../core/network/dio_client.dart';\n\n/// Base class for all repositories\n/// Provides common functionality for API calls and error handling\nabstract class BaseRepository {\n  final DioClient dioClient;\n  \n  const BaseRepository({required this.dioClient});\n  \n  /// Wraps API calls with standard error handling\n  /// Returns data on success, throws AppException on failure\n  Future<T> safeApiCall<T>(\n    Future<Response<dynamic>> Function() apiCall,\n    T Function(dynamic data) parser,\n  ) async {\n    try {\n      final response = await apiCall();\n      return parser(response.data);\n    } on AppException {\n      rethrow;\n    } catch (e) {\n      throw AppException(\n        message: 'Unexpected error occurred',\n        code: 'UNEXPECTED',\n        originalError: e,\n      );\n    }\n  }\n  \n  /// Converts AppException to Failure for cleaner error handling in UI\n  Failure mapExceptionToFailure(AppException exception) {\n    if (exception is NetworkException) {\n      return NetworkFailure(message: exception.message, code: exception.code);\n    }\n    if (exception is AuthException) {\n      return AuthFailure(message: exception.message, code: exception.code);\n    }\n    if (exception is ValidationException) {\n      return ValidationFailure(message: exception.message, code: exception.code);\n    }\n    if (exception is ServerException) {\n      return ServerFailure(\n        message: exception.message,\n        code: exception.code,\n        statusCode: exception.statusCode,\n      );\n    }\n    return ServerFailure(message: exception.message, code: exception.code);\n  }\n}\n```\n\n**injection_container.dart:**\n```dart\nimport 'package:flutter_secure_storage/flutter_secure_storage.dart';\nimport 'package:get_it/get_it.dart';\n\nimport 'core/config/app_config.dart';\nimport 'core/config/environment.dart';\nimport 'core/network/dio_client.dart';\nimport 'core/utils/logger.dart';\n\nfinal sl = GetIt.instance;\n\n/// Initialize all dependencies\n/// Call this in main() before runApp()\nFuture<void> initDependencies({EnvironmentConfig? environment}) async {\n  // Initialize environment configuration\n  AppConfig.init(environment ?? EnvironmentConfig.development);\n  \n  // Initialize logger\n  AppLogger.init();\n  \n  // External dependencies\n  _initExternalDependencies();\n  \n  // Core\n  _initCore();\n  \n  // Repositories\n  _initRepositories();\n  \n  // Services\n  _initServices();\n  \n  AppLogger.i('Dependencies initialized successfully');\n}\n\nvoid _initExternalDependencies() {\n  // Secure Storage\n  sl.registerLazySingleton<FlutterSecureStorage>(\n    () => const FlutterSecureStorage(\n      aOptions: AndroidOptions(\n        encryptedSharedPreferences: true,\n      ),\n      iOptions: IOSOptions(\n        accessibility: KeychainAccessibility.first_unlock_this_device,\n      ),\n    ),\n  );\n}\n\nvoid _initCore() {\n  // Dio Client\n  sl.registerLazySingleton<DioClient>(\n    () => DioClient(secureStorage: sl<FlutterSecureStorage>()),\n  );\n}\n\nvoid _initRepositories() {\n  // Repositories will be registered here in future epics\n  // Example:\n  // sl.registerLazySingleton<AuthRepository>(\n  //   () => AuthRepositoryImpl(dioClient: sl()),\n  // );\n}\n\nvoid _initServices() {\n  // Services will be registered here in future epics\n  // Example:\n  // sl.registerLazySingleton<AuthService>(\n  //   () => AuthServiceImpl(authRepository: sl()),\n  // );\n}\n\n/// Reset all registered dependencies (useful for testing)\nFuture<void> resetDependencies() async {\n  await sl.reset();\n}\n```\n\n**lib/main.dart (MODIFIED):**\n```dart\nimport 'package:flutter/material.dart';\nimport 'core/config/environment.dart';\nimport 'injection_container.dart';\n\nvoid main() async {\n  WidgetsFlutterBinding.ensureInitialized();\n  \n  // Initialize dependencies with development environment\n  // Change to EnvironmentConfig.production for release builds\n  await initDependencies(environment: EnvironmentConfig.development);\n  \n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'App Pasos',\n      debugShowCheckedModeBanner: false,\n      theme: ThemeData(\n        colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue),\n        useMaterial3: true,\n      ),\n      home: const HomePage(),\n    );\n  }\n}\n\n/// Temporary home page - will be replaced with proper routing in future epic\nclass HomePage extends StatelessWidget {\n  const HomePage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('App Pasos'),\n        backgroundColor: Theme.of(context).colorScheme.inversePrimary,\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Icon(\n              Icons.directions_walk,\n              size: 64,\n              color: Theme.of(context).colorScheme.primary,\n            ),\n            const SizedBox(height: 16),\n            Text(\n              'Welcome to App Pasos',\n              style: Theme.of(context).textTheme.headlineMedium,\n            ),\n            const SizedBox(height: 8),\n            Text(\n              'Foundation Setup Complete',\n              style: Theme.of(context).textTheme.bodyLarge?.copyWith(\n                    color: Colors.grey,\n                  ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n```\n\n‚ö†Ô∏è **ANTI-PATTERNS TO AVOID:**\n- Registering dependencies as factories when singletons are needed ‚Üê WRONG\n- Not calling WidgetsFlutterBinding.ensureInitialized() before async work ‚Üê CRASH\n- Using GetIt.I instead of the exported `sl` variable ‚Üê Inconsistent\n- Not providing AndroidOptions/IOSOptions for FlutterSecureStorage ‚Üê Security issues\n\nüéØ **FUNCTIONAL REQUIREMENTS:**\n- Dependencies initialized before runApp()\n- FlutterSecureStorage configured with encryption\n- DioClient available via sl<DioClient>()\n- App runs and shows welcome screen\n\nüß™ **VERIFICATION:**\n```bash\nflutter analyze\nflutter build apk --debug\n```",
        "epicId": "epic-flutter-foundation",
        "priority": 5,
        "estimatedComplexity": "moderate",
        "dependencies": [
          "epic-flutter-foundation-story-2",
          "epic-flutter-foundation-story-3"
        ],
        "status": "pending",
        "filesToRead": [
          "lib/main.dart"
        ],
        "filesToModify": [
          "lib/main.dart"
        ],
        "filesToCreate": [
          "lib/injection_container.dart",
          "lib/data/repositories/base_repository.dart"
        ],
        "acceptanceCriteria": [
          "Given initDependencies() is called, When checking sl<DioClient>(), Then a valid DioClient instance is returned",
          "Given main.dart is modified, When app starts, Then dependencies are initialized before MaterialApp renders",
          "Given FlutterSecureStorage is registered, When accessing sl<FlutterSecureStorage>(), Then storage is configured with encryption options",
          "Given app builds, When running flutter build, Then no compilation errors occur"
        ]
      }
    ]
  }
}