{
  "_metadata": {
    "agentType": "techlead",
    "taskId": "755214819d2c213608fe0167",
    "timestamp": "2026-01-29T18:54:51.837Z",
    "phase": "techlead",
    "epicId": "epic-push-notifications",
    "savedAt": "2026-01-29T18:54:51.837Z",
    "version": "1.0"
  },
  "data": {
    "epicId": "epic-push-notifications",
    "storiesCount": 4,
    "architecture": "## Push Notifications Architecture\n\n### Service Abstraction Pattern (Following Existing Codebase)\n\nThe notification system follows the established service pattern in the codebase:\n\n1. **NotificationService** (abstract interface) - Defines the contract for push notification operations\n2. **NotificationServiceImpl** - Firebase Cloud Messaging implementation\n3. **NotificationHandler** - Handles deep linking and navigation from notifications\n\n### Integration Points\n\n```\nmain.dart\n    ‚îú‚îÄ‚îÄ initializeDependencies() (registers NotificationService, NotificationHandler)\n    ‚îú‚îÄ‚îÄ sl<NotificationService>().initialize()\n    ‚îú‚îÄ‚îÄ sl<NotificationService>().requestPermission()\n    ‚îî‚îÄ‚îÄ sl<NotificationHandler>().initialize()\n\napp.dart\n    ‚îî‚îÄ‚îÄ _logFcmToken() (debugging helper)\n\ninjection_container.dart\n    ‚îú‚îÄ‚îÄ NotificationService (LazySingleton)\n    ‚îî‚îÄ‚îÄ NotificationHandler (LazySingleton)\n```\n\n### Deep Link Routing Strategy\n\nNotifications contain a `type` field that maps to routes:\n- `friend_request` ‚Üí `/friends/requests`\n- `goal_invite` ‚Üí `/goals/detail?goalId={goalId}`\n- `goal_progress` ‚Üí `/goals/detail?goalId={goalId}`\n- `friend_activity` ‚Üí `/friends/activity?friendId={friendId}`\n- Default ‚Üí `/dashboard`\n\n### Platform Configuration\n\n**Android:**\n- google-services.json in android/app/\n- Google services Gradle plugin in build.gradle\n\n**iOS:**\n- GoogleService-Info.plist in ios/Runner/\n- Firebase initialization in AppDelegate.swift\n- APNs capability configuration\n\n### SOLID Principles Compliance\n\n- **SRP**: NotificationService handles FCM, NotificationHandler handles navigation\n- **OCP**: Interface allows swapping implementations (e.g., for testing)\n- **LSP**: NotificationServiceImpl fully honors NotificationService contract\n- **ISP**: Small, focused interface methods\n- **DIP**: Depends on abstractions (NotificationService interface)\n\n### Setup Commands\n```bash\nflutter pub get\n```\n\n### Verification Commands\n- Analyze: `flutter analyze`\n- Build Android: `flutter build apk --debug`\n- Build iOS: `flutter build ios --no-codesign`\n\n**Note:** Firebase config files contain placeholders. User must replace with real Firebase project credentials from Firebase Console.",
    "stories": [
      {
        "id": "epic-push-notifications-story-1",
        "title": "Add Firebase dependencies to pubspec.yaml and configure Android build files",
        "description": "Add Firebase Core and Firebase Messaging dependencies to the Flutter project and configure Android Gradle files for Firebase integration.\n\nüîí **SCOPE BOUNDARY:**\n- You can ONLY create/modify files listed below\n- Creating ANY other file is a scope violation\n\nüìÅ **FILES:**\n- Read: lib/main.dart (understand initialization pattern)\n- Modify: pubspec.yaml, android/build.gradle, android/app/build.gradle\n- Create: android/app/google-services.json\n\nüîß **PATTERNS TO USE:**\n- Follow existing dependency structure in pubspec.yaml (use caret syntax ^x.x.x)\n- Firebase packages to add: firebase_core: ^2.24.2, firebase_messaging: ^14.7.10\n- Android build.gradle pattern: Add google-services classpath to buildscript dependencies\n- App build.gradle pattern: Apply google-services plugin at the bottom\n\nüì¶ **REQUIRED CHANGES:**\n\n1. **pubspec.yaml** - Add dependencies:\n```yaml\ndependencies:\n  firebase_core: ^2.24.2\n  firebase_messaging: ^14.7.10\n```\n\n2. **android/build.gradle** - Add in buildscript.dependencies:\n```groovy\nbuildscript {\n    dependencies {\n        classpath 'com.google.gms:google-services:4.4.0'\n    }\n}\n```\n\n3. **android/app/build.gradle** - Add at the end:\n```groovy\napply plugin: 'com.google.gms.google-services'\n```\n\n4. **android/app/google-services.json** - Create placeholder file with structure:\n```json\n{\n  \"project_info\": {\n    \"project_number\": \"PLACEHOLDER_PROJECT_NUMBER\",\n    \"project_id\": \"PLACEHOLDER_PROJECT_ID\",\n    \"storage_bucket\": \"PLACEHOLDER_STORAGE_BUCKET\"\n  },\n  \"client\": [\n    {\n      \"client_info\": {\n        \"mobilesdk_app_id\": \"1:PLACEHOLDER:android:PLACEHOLDER\",\n        \"android_client_info\": {\n          \"package_name\": \"com.example.pasos.app_pasos_frontend\"\n        }\n      },\n      \"api_key\": [\n        {\n          \"current_key\": \"PLACEHOLDER_API_KEY\"\n        }\n      ]\n    }\n  ],\n  \"configuration_version\": \"1\"\n}\n```\nNote: User must replace with real Firebase config from Firebase Console.\n\n‚ö†Ô∏è **ANTI-PATTERNS TO AVOID:**\n- DO NOT add dependencies without version constraints\n- DO NOT modify minSdk (already set to 28 for Health Connect)\n- DO NOT add firebase_options.dart (will be generated by flutterfire CLI)\n\nüß™ **VERIFICATION:**\n```bash\nflutter pub get\nflutter build apk --debug 2>&1 | head -50\n```\nExpected: Dependencies resolve successfully, Android build starts without Gradle errors",
        "epicId": "epic-push-notifications",
        "priority": 1,
        "estimatedComplexity": "moderate",
        "dependencies": [],
        "status": "pending",
        "filesToRead": [
          "lib/main.dart"
        ],
        "filesToModify": [
          "pubspec.yaml",
          "android/build.gradle",
          "android/app/build.gradle"
        ],
        "filesToCreate": [
          "android/app/google-services.json"
        ],
        "acceptanceCriteria": [
          "Given pubspec.yaml, When firebase_core and firebase_messaging are added, Then flutter pub get succeeds without errors",
          "Given android/build.gradle, When google-services classpath is added, Then Gradle sync completes successfully",
          "Given android/app/build.gradle, When google-services plugin is applied, Then Android build compiles",
          "Given android/app/google-services.json placeholder, When file is created with correct structure, Then it matches the package_name com.example.pasos.app_pasos_frontend"
        ]
      },
      {
        "id": "epic-push-notifications-story-2",
        "title": "Configure iOS platform for Firebase push notifications in AppDelegate.swift",
        "description": "Configure iOS for Firebase Cloud Messaging including AppDelegate modifications and placeholder Firebase config files.\n\nüîí **SCOPE BOUNDARY:**\n- You can ONLY create/modify files listed below\n- Creating ANY other file is a scope violation\n\nüìÅ **FILES:**\n- Read: ios/Runner/AppDelegate.swift (understand current structure)\n- Modify: ios/Runner/AppDelegate.swift\n- Create: ios/Runner/GoogleService-Info.plist, ios/firebase_app_id_file.json\n\nüîß **PATTERNS TO USE:**\n- Follow Flutter iOS Firebase pattern: import FirebaseCore and FirebaseMessaging\n- Initialize Firebase in application:didFinishLaunchingWithOptions before GeneratedPluginRegistrant\n- Configure APNs and request notification authorization\n\nüì¶ **REQUIRED CHANGES:**\n\n1. **ios/Runner/AppDelegate.swift** - Full replacement:\n```swift\nimport Flutter\nimport UIKit\nimport FirebaseCore\nimport FirebaseMessaging\n\n@main\n@objc class AppDelegate: FlutterAppDelegate {\n  override func application(\n    _ application: UIApplication,\n    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?\n  ) -> Bool {\n    // Initialize Firebase\n    FirebaseApp.configure()\n    \n    // Configure push notifications\n    UNUserNotificationCenter.current().delegate = self\n    \n    // Request notification authorization\n    let authOptions: UNAuthorizationOptions = [.alert, .badge, .sound]\n    UNUserNotificationCenter.current().requestAuthorization(\n      options: authOptions,\n      completionHandler: { _, _ in }\n    )\n    \n    application.registerForRemoteNotifications()\n    \n    // Set FCM messaging delegate\n    Messaging.messaging().delegate = self\n    \n    GeneratedPluginRegistrant.register(with: self)\n    return super.application(application, didFinishLaunchingWithOptions: launchOptions)\n  }\n  \n  // Handle device token registration\n  override func application(\n    _ application: UIApplication,\n    didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data\n  ) {\n    Messaging.messaging().apnsToken = deviceToken\n  }\n}\n\n// MARK: - MessagingDelegate\nextension AppDelegate: MessagingDelegate {\n  func messaging(\n    _ messaging: Messaging,\n    didReceiveRegistrationToken fcmToken: String?\n  ) {\n    let tokenDict = [\"token\": fcmToken ?? \"\"]\n    NotificationCenter.default.post(\n      name: Notification.Name(\"FCMToken\"),\n      object: nil,\n      userInfo: tokenDict\n    )\n  }\n}\n```\n\n2. **ios/Runner/GoogleService-Info.plist** - Create placeholder:\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n  <key>CLIENT_ID</key>\n  <string>PLACEHOLDER_CLIENT_ID</string>\n  <key>REVERSED_CLIENT_ID</key>\n  <string>PLACEHOLDER_REVERSED_CLIENT_ID</string>\n  <key>API_KEY</key>\n  <string>PLACEHOLDER_API_KEY</string>\n  <key>GCM_SENDER_ID</key>\n  <string>PLACEHOLDER_GCM_SENDER_ID</string>\n  <key>PLIST_VERSION</key>\n  <string>1</string>\n  <key>BUNDLE_ID</key>\n  <string>com.example.pasos.appPasosFrontend</string>\n  <key>PROJECT_ID</key>\n  <string>PLACEHOLDER_PROJECT_ID</string>\n  <key>STORAGE_BUCKET</key>\n  <string>PLACEHOLDER_STORAGE_BUCKET</string>\n  <key>IS_ADS_ENABLED</key>\n  <false/>\n  <key>IS_ANALYTICS_ENABLED</key>\n  <false/>\n  <key>IS_APPINVITE_ENABLED</key>\n  <true/>\n  <key>IS_GCM_ENABLED</key>\n  <true/>\n  <key>IS_SIGNIN_ENABLED</key>\n  <true/>\n  <key>GOOGLE_APP_ID</key>\n  <string>PLACEHOLDER_GOOGLE_APP_ID</string>\n</dict>\n</plist>\n```\n\n3. **ios/firebase_app_id_file.json** - Create placeholder:\n```json\n{\n  \"file_generated_by\": \"FlutterFire CLI\",\n  \"purpose\": \"FirebaseAppID & ProjectID for this Firebase app in this directory\",\n  \"GOOGLE_APP_ID\": \"PLACEHOLDER_GOOGLE_APP_ID\",\n  \"FIREBASE_PROJECT_ID\": \"PLACEHOLDER_PROJECT_ID\",\n  \"GCM_SENDER_ID\": \"PLACEHOLDER_GCM_SENDER_ID\"\n}\n```\n\n‚ö†Ô∏è **ANTI-PATTERNS TO AVOID:**\n- DO NOT remove GeneratedPluginRegistrant.register(with: self)\n- DO NOT remove super.application call\n- DO NOT add real Firebase credentials - use placeholders\n\nüß™ **VERIFICATION:**\n```bash\ncd ios && pod install && cd ..\nflutter build ios --no-codesign 2>&1 | head -50\n```\nExpected: iOS build compiles (may warn about missing real Firebase config)",
        "epicId": "epic-push-notifications",
        "priority": 1,
        "estimatedComplexity": "moderate",
        "dependencies": [],
        "status": "pending",
        "filesToRead": [
          "ios/Runner/AppDelegate.swift"
        ],
        "filesToModify": [
          "ios/Runner/AppDelegate.swift"
        ],
        "filesToCreate": [
          "ios/Runner/GoogleService-Info.plist",
          "ios/firebase_app_id_file.json"
        ],
        "acceptanceCriteria": [
          "Given AppDelegate.swift, When FirebaseCore and FirebaseMessaging imports are added, Then imports compile without errors",
          "Given AppDelegate.swift, When FirebaseApp.configure() is called before plugin registration, Then Firebase initializes before Flutter engine",
          "Given AppDelegate.swift, When UNUserNotificationCenter delegate is set, Then notification events route to AppDelegate",
          "Given GoogleService-Info.plist placeholder, When created with correct BUNDLE_ID, Then it matches com.example.pasos.appPasosFrontend"
        ]
      },
      {
        "id": "epic-push-notifications-story-3",
        "title": "Create NotificationService interface and NotificationServiceImpl in lib/core/services/",
        "description": "Create the NotificationService abstract interface and its Firebase Cloud Messaging implementation following the existing service pattern.\n\nüîí **SCOPE BOUNDARY:**\n- You can ONLY create/modify files listed below\n- Creating ANY other file is a scope violation\n\nüìÅ **FILES:**\n- Read: lib/core/services/background_sync_service.dart, lib/core/services/background_sync_service_impl.dart, lib/core/services/health_service.dart (understand service pattern)\n- Modify: None\n- Create: lib/core/services/notification_service.dart, lib/core/services/notification_service_impl.dart\n\nüîß **PATTERNS TO USE:**\n- Follow EXACT pattern from BackgroundSyncService: abstract interface class + Impl class\n- Use library; directive at top of file\n- Use documentation comments (///) for all public members\n- Imports should be organized: dart:, package:firebase_*, package:app_pasos_frontend/*\n\nüì¶ **REQUIRED IMPLEMENTATION:**\n\n1. **lib/core/services/notification_service.dart** - Abstract interface:\n```dart\n/// Push notification service for Firebase Cloud Messaging in App Pasos.\n///\n/// This file defines an abstract interface for push notification operations.\n/// Implementations will provide Firebase Cloud Messaging integration for\n/// receiving and handling push notifications.\nlibrary;\n\n/// Abstract interface for push notification operations.\n///\n/// This interface enables dependency injection and testing by allowing\n/// mock implementations. All push notification logic should go\n/// through this service.\n///\n/// The notification service handles:\n/// - Requesting notification permissions from the user\n/// - Getting and managing FCM tokens\n/// - Listening to incoming notifications\n/// - Handling foreground and background notifications\nabstract interface class NotificationService {\n  /// Initializes the notification service.\n  ///\n  /// This method must be called before any other notification operations.\n  /// It sets up Firebase Messaging and registers for notifications.\n  Future<void> initialize();\n\n  /// Requests permission to display notifications.\n  ///\n  /// Returns true if permission was granted, false otherwise.\n  Future<bool> requestPermission();\n\n  /// Gets the current FCM token for this device.\n  ///\n  /// Returns the token string, or null if not available.\n  Future<String?> getToken();\n\n  /// Stream of FCM token refreshes.\n  ///\n  /// Listen to this stream to get notified when the token changes.\n  Stream<String> get onTokenRefresh;\n\n  /// Stream of notification messages received while app is in foreground.\n  Stream<NotificationMessage> get onMessage;\n\n  /// Stream of notification taps (when user taps a notification).\n  Stream<NotificationMessage> get onMessageOpenedApp;\n\n  /// Gets the initial message that launched the app (if any).\n  ///\n  /// Returns the notification message if app was opened from a notification.\n  Future<NotificationMessage?> getInitialMessage();\n\n  /// Subscribes to a topic for targeted notifications.\n  Future<void> subscribeToTopic(String topic);\n\n  /// Unsubscribes from a topic.\n  Future<void> unsubscribeFromTopic(String topic);\n}\n\n/// Represents a push notification message.\n///\n/// Contains the notification data and optional deep link information.\nclass NotificationMessage {\n  /// Creates a [NotificationMessage].\n  const NotificationMessage({\n    this.title,\n    this.body,\n    this.data = const {},\n    this.deepLink,\n  });\n\n  /// The notification title.\n  final String? title;\n\n  /// The notification body text.\n  final String? body;\n\n  /// Custom data payload from the notification.\n  final Map<String, dynamic> data;\n\n  /// Deep link route to navigate to (extracted from data).\n  final String? deepLink;\n}\n```\n\n2. **lib/core/services/notification_service_impl.dart** - Implementation:\n```dart\n/// Push notification service implementation using Firebase Cloud Messaging.\n///\n/// This file provides the concrete implementation of [NotificationService]\n/// using Firebase Messaging for cross-platform push notifications.\nlibrary;\n\nimport 'dart:async';\n\nimport 'package:app_pasos_frontend/core/services/notification_service.dart';\nimport 'package:firebase_messaging/firebase_messaging.dart';\nimport 'package:flutter/foundation.dart';\n\n/// Implementation of [NotificationService] using Firebase Cloud Messaging.\n///\n/// This implementation provides push notification capabilities through:\n/// - FCM token management\n/// - Permission handling\n/// - Foreground and background message handling\n/// - Topic subscription management\nclass NotificationServiceImpl implements NotificationService {\n  /// Creates a [NotificationServiceImpl] instance.\n  NotificationServiceImpl({FirebaseMessaging? messaging})\n      : _messaging = messaging ?? FirebaseMessaging.instance;\n\n  /// The Firebase Messaging instance.\n  final FirebaseMessaging _messaging;\n\n  /// Stream controller for token refresh events.\n  final _tokenRefreshController = StreamController<String>.broadcast();\n\n  /// Stream controller for foreground messages.\n  final _messageController = StreamController<NotificationMessage>.broadcast();\n\n  /// Stream controller for notification tap events.\n  final _messageOpenedController = StreamController<NotificationMessage>.broadcast();\n\n  /// Tracks initialization state.\n  bool _isInitialized = false;\n\n  @override\n  Future<void> initialize() async {\n    if (_isInitialized) return;\n\n    // Configure foreground notification presentation\n    await _messaging.setForegroundNotificationPresentationOptions(\n      alert: true,\n      badge: true,\n      sound: true,\n    );\n\n    // Listen to foreground messages\n    FirebaseMessaging.onMessage.listen((RemoteMessage message) {\n      _messageController.add(_convertMessage(message));\n    });\n\n    // Listen to notification taps (app in background)\n    FirebaseMessaging.onMessageOpenedApp.listen((RemoteMessage message) {\n      _messageOpenedController.add(_convertMessage(message));\n    });\n\n    // Listen to token refreshes\n    _messaging.onTokenRefresh.listen((token) {\n      _tokenRefreshController.add(token);\n    });\n\n    _isInitialized = true;\n    debugPrint('NotificationService initialized');\n  }\n\n  @override\n  Future<bool> requestPermission() async {\n    final settings = await _messaging.requestPermission(\n      alert: true,\n      announcement: false,\n      badge: true,\n      carPlay: false,\n      criticalAlert: false,\n      provisional: false,\n      sound: true,\n    );\n\n    return settings.authorizationStatus == AuthorizationStatus.authorized ||\n        settings.authorizationStatus == AuthorizationStatus.provisional;\n  }\n\n  @override\n  Future<String?> getToken() async {\n    try {\n      return await _messaging.getToken();\n    } catch (e) {\n      debugPrint('Error getting FCM token: $e');\n      return null;\n    }\n  }\n\n  @override\n  Stream<String> get onTokenRefresh => _tokenRefreshController.stream;\n\n  @override\n  Stream<NotificationMessage> get onMessage => _messageController.stream;\n\n  @override\n  Stream<NotificationMessage> get onMessageOpenedApp => _messageOpenedController.stream;\n\n  @override\n  Future<NotificationMessage?> getInitialMessage() async {\n    final message = await _messaging.getInitialMessage();\n    return message != null ? _convertMessage(message) : null;\n  }\n\n  @override\n  Future<void> subscribeToTopic(String topic) async {\n    await _messaging.subscribeToTopic(topic);\n    debugPrint('Subscribed to topic: $topic');\n  }\n\n  @override\n  Future<void> unsubscribeFromTopic(String topic) async {\n    await _messaging.unsubscribeFromTopic(topic);\n    debugPrint('Unsubscribed from topic: $topic');\n  }\n\n  /// Converts a Firebase RemoteMessage to NotificationMessage.\n  NotificationMessage _convertMessage(RemoteMessage message) {\n    return NotificationMessage(\n      title: message.notification?.title,\n      body: message.notification?.body,\n      data: message.data,\n      deepLink: message.data['deepLink'] as String? ??\n          message.data['route'] as String?,\n    );\n  }\n}\n```\n\n‚ö†Ô∏è **ANTI-PATTERNS TO AVOID:**\n- DO NOT use concrete class instead of interface (use abstract interface class)\n- DO NOT forget library; directive at file start\n- DO NOT skip documentation comments for public APIs\n- DO NOT create BLoC in this story (that would be a different pattern)\n\nüß™ **VERIFICATION:**\n```bash\nflutter analyze lib/core/services/notification_service.dart lib/core/services/notification_service_impl.dart\nflutter build apk --debug 2>&1 | grep -i error | head -10\n```\nExpected: No analysis errors, service files compile successfully",
        "epicId": "epic-push-notifications",
        "priority": 2,
        "estimatedComplexity": "moderate",
        "dependencies": [
          "epic-push-notifications-story-1"
        ],
        "status": "pending",
        "filesToRead": [
          "lib/core/services/background_sync_service.dart",
          "lib/core/services/background_sync_service_impl.dart",
          "lib/core/services/health_service.dart"
        ],
        "filesToModify": [],
        "filesToCreate": [
          "lib/core/services/notification_service.dart",
          "lib/core/services/notification_service_impl.dart"
        ],
        "acceptanceCriteria": [
          "Given notification_service.dart, When abstract interface class NotificationService is defined, Then it follows BackgroundSyncService pattern exactly",
          "Given notification_service_impl.dart, When NotificationServiceImpl implements NotificationService, Then all interface methods are implemented",
          "Given NotificationMessage class, When created with notification data, Then title, body, data, and deepLink are accessible",
          "Given flutter analyze, When run on both files, Then zero errors and zero warnings are reported"
        ]
      },
      {
        "id": "epic-push-notifications-story-4",
        "title": "Create NotificationHandler and register services in injection_container.dart and main.dart",
        "description": "Create the NotificationHandler for deep link navigation and integrate notification services into the app initialization flow.\n\nüîí **SCOPE BOUNDARY:**\n- You can ONLY create/modify files listed below\n- Creating ANY other file is a scope violation\n\nüìÅ **FILES:**\n- Read: lib/core/di/injection_container.dart, lib/main.dart, lib/app.dart, lib/core/router/app_router.dart (understand DI and initialization patterns)\n- Modify: lib/core/di/injection_container.dart, lib/main.dart, lib/app.dart\n- Create: lib/core/services/notification_handler.dart\n\nüîß **PATTERNS TO USE:**\n- DI registration: Use sl.registerLazySingleton<NotificationService>(NotificationServiceImpl.new)\n- Initialization in main.dart: Follow BackgroundSyncService pattern (initialize after initializeDependencies)\n- Use GoRouter for deep link navigation (AppRouter.router.go(route))\n\nüì¶ **REQUIRED IMPLEMENTATION:**\n\n1. **lib/core/services/notification_handler.dart** - Create:\n```dart\n/// Notification handler for routing push notification deep links.\n///\n/// This file provides a handler that listens to notification events\n/// and navigates to appropriate screens using GoRouter.\nlibrary;\n\nimport 'dart:async';\n\nimport 'package:app_pasos_frontend/core/router/app_router.dart';\nimport 'package:app_pasos_frontend/core/router/route_names.dart';\nimport 'package:app_pasos_frontend/core/services/notification_service.dart';\nimport 'package:flutter/foundation.dart';\n\n/// Handles notification-triggered navigation and deep linking.\n///\n/// This handler:\n/// - Listens to notification tap events\n/// - Parses deep link routes from notification data\n/// - Navigates to appropriate screens using GoRouter\n///\n/// Example usage:\n/// ```dart\n/// final handler = NotificationHandler(notificationService: sl<NotificationService>());\n/// await handler.initialize();\n/// ```\nclass NotificationHandler {\n  /// Creates a [NotificationHandler] instance.\n  NotificationHandler({required NotificationService notificationService})\n      : _notificationService = notificationService;\n\n  /// The notification service instance.\n  final NotificationService _notificationService;\n\n  /// Subscriptions to notification streams.\n  final List<StreamSubscription<dynamic>> _subscriptions = [];\n\n  /// Tracks initialization state.\n  bool _isInitialized = false;\n\n  /// Initializes the notification handler.\n  ///\n  /// Sets up listeners for:\n  /// - Initial notification (app launched from notification)\n  /// - Notification taps while app is running\n  Future<void> initialize() async {\n    if (_isInitialized) return;\n\n    // Handle initial notification (app opened from terminated state)\n    final initialMessage = await _notificationService.getInitialMessage();\n    if (initialMessage != null) {\n      _handleNotificationNavigation(initialMessage);\n    }\n\n    // Listen to notification taps while app is in background/foreground\n    _subscriptions.add(\n      _notificationService.onMessageOpenedApp.listen(_handleNotificationNavigation),\n    );\n\n    // Optionally handle foreground notifications\n    _subscriptions.add(\n      _notificationService.onMessage.listen(_handleForegroundMessage),\n    );\n\n    _isInitialized = true;\n    debugPrint('NotificationHandler initialized');\n  }\n\n  /// Handles navigation when a notification is tapped.\n  void _handleNotificationNavigation(NotificationMessage message) {\n    final route = _parseDeepLink(message);\n    if (route != null) {\n      debugPrint('Navigating to deep link: $route');\n      AppRouter.router.go(route);\n    }\n  }\n\n  /// Handles foreground notification display.\n  void _handleForegroundMessage(NotificationMessage message) {\n    // Log foreground message (can be extended to show in-app notification)\n    debugPrint('Foreground notification: ${message.title}');\n  }\n\n  /// Parses the deep link route from notification data.\n  String? _parseDeepLink(NotificationMessage message) {\n    // First check explicit deepLink field\n    if (message.deepLink != null && message.deepLink!.isNotEmpty) {\n      return _validateRoute(message.deepLink!);\n    }\n\n    // Check for specific notification types and map to routes\n    final notificationType = message.data['type'] as String?;\n    switch (notificationType) {\n      case 'friend_request':\n        return RouteNames.friendRequests;\n      case 'goal_invite':\n        final goalId = message.data['goalId'] as String?;\n        return goalId != null\n            ? '${RouteNames.goalDetail}?goalId=$goalId'\n            : RouteNames.goals;\n      case 'goal_progress':\n        final goalId = message.data['goalId'] as String?;\n        return goalId != null\n            ? '${RouteNames.goalDetail}?goalId=$goalId'\n            : RouteNames.goals;\n      case 'friend_activity':\n        final friendId = message.data['friendId'] as String?;\n        return friendId != null\n            ? '${RouteNames.friendActivity}?friendId=$friendId'\n            : RouteNames.friends;\n      default:\n        return RouteNames.dashboard;\n    }\n  }\n\n  /// Validates that the route exists in the app.\n  String? _validateRoute(String route) {\n    // List of valid routes\n    const validPrefixes = [\n      RouteNames.home,\n      RouteNames.login,\n      RouteNames.dashboard,\n      RouteNames.profile,\n      RouteNames.settings,\n      RouteNames.friends,\n      RouteNames.goals,\n    ];\n\n    for (final prefix in validPrefixes) {\n      if (route.startsWith(prefix)) {\n        return route;\n      }\n    }\n\n    debugPrint('Invalid deep link route: $route, defaulting to dashboard');\n    return RouteNames.dashboard;\n  }\n\n  /// Disposes of stream subscriptions.\n  void dispose() {\n    for (final subscription in _subscriptions) {\n      subscription.cancel();\n    }\n    _subscriptions.clear();\n    _isInitialized = false;\n  }\n}\n```\n\n2. **lib/core/di/injection_container.dart** - Add after WebSocket Services section:\n```dart\n// ============================================================\n// Notification Services\n// ============================================================\n\n// Notification Service - For push notifications via FCM\nsl.registerLazySingleton<NotificationService>(NotificationServiceImpl.new);\n\n// Notification Handler - Routes notifications to appropriate screens\nsl.registerLazySingleton<NotificationHandler>(\n  () => NotificationHandler(notificationService: sl<NotificationService>()),\n);\n```\nAlso add imports at top:\n```dart\nimport 'package:app_pasos_frontend/core/services/notification_service.dart';\nimport 'package:app_pasos_frontend/core/services/notification_service_impl.dart';\nimport 'package:app_pasos_frontend/core/services/notification_handler.dart';\n```\n\n3. **lib/main.dart** - Add notification initialization after BackgroundSyncService:\n```dart\n// Initialize notification service.\n// This sets up Firebase Messaging and registers for notifications.\nawait sl<NotificationService>().initialize();\n\n// Request notification permission.\nawait sl<NotificationService>().requestPermission();\n\n// Initialize notification handler for deep linking.\nawait sl<NotificationHandler>().initialize();\n```\nAlso add imports:\n```dart\nimport 'package:app_pasos_frontend/core/services/notification_service.dart';\nimport 'package:app_pasos_frontend/core/services/notification_handler.dart';\n```\n\n4. **lib/app.dart** - Add token logging in _initializeWebSocket method (for debugging):\n```dart\n// Log FCM token for testing (remove in production)\n_logFcmToken();\n```\nAnd add the helper method:\n```dart\n/// Logs the FCM token for debugging purposes.\nvoid _logFcmToken() async {\n  final notificationService = sl<NotificationService>();\n  final token = await notificationService.getToken();\n  debugPrint('FCM Token: $token');\n}\n```\nAlso add import:\n```dart\nimport 'package:app_pasos_frontend/core/services/notification_service.dart';\n```\n\n‚ö†Ô∏è **ANTI-PATTERNS TO AVOID:**\n- DO NOT use registerFactory for services (use registerLazySingleton like other core services)\n- DO NOT initialize notification service before dependency injection is complete\n- DO NOT hardcode routes - use RouteNames constants\n- DO NOT forget to import NotificationService in files that use sl<NotificationService>()\n\nüéØ **FUNCTIONAL REQUIREMENTS:**\n- NotificationHandler must parse 'type' field from notification data to route correctly\n- Deep links for friend_request ‚Üí /friends/requests\n- Deep links for goal_invite ‚Üí /goals/detail?goalId=X\n- Deep links for friend_activity ‚Üí /friends/activity?friendId=X\n- Default fallback ‚Üí /dashboard\n\nüß™ **VERIFICATION:**\n```bash\nflutter analyze\nflutter build apk --debug\n```\nExpected: Build succeeds, FCM token prints to debug console on app launch",
        "epicId": "epic-push-notifications",
        "priority": 3,
        "estimatedComplexity": "complex",
        "dependencies": [
          "epic-push-notifications-story-3"
        ],
        "status": "pending",
        "filesToRead": [
          "lib/core/di/injection_container.dart",
          "lib/main.dart",
          "lib/app.dart",
          "lib/core/router/app_router.dart",
          "lib/core/router/route_names.dart"
        ],
        "filesToModify": [
          "lib/core/di/injection_container.dart",
          "lib/main.dart",
          "lib/app.dart"
        ],
        "filesToCreate": [
          "lib/core/services/notification_handler.dart"
        ],
        "acceptanceCriteria": [
          "Given notification_handler.dart, When NotificationHandler is created with NotificationService dependency, Then it can parse notification types to routes",
          "Given injection_container.dart, When NotificationService and NotificationHandler are registered as LazySingleton, Then sl<NotificationService>() returns the same instance",
          "Given main.dart, When notification services are initialized after initializeDependencies(), Then initialization order follows BackgroundSyncService pattern",
          "Given app launch, When FCM token is retrieved, Then token is printed to debug console",
          "Given notification with type='friend_request', When notification is tapped, Then app navigates to /friends/requests"
        ]
      }
    ]
  }
}